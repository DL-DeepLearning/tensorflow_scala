/* DO NOT EDIT THIS FILE - it is machine generated */

/* Copyright 2017, Emmanouil Antonios Platanios. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

#include "tensor_nn_ops.h"

#include <algorithm>
#include <cstring>
#include <memory>
#include <sstream>

#include "include/c_api.h"
#include "include/c_eager_api.h"
#include "include/exception_jni.h"
#include "include/utilities.h"

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_biasAdd(
    JNIEnv* env, jobject object, jlong context_handle, jlong value, jlong bias, jbyteArray data_format) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "BiasAdd", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(value_tensor_handle, TFE_TensorHandle, value, 0);
  TFE_OpAddInput(op.get(), value_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(bias_tensor_handle, TFE_TensorHandle, bias, 0);
  TFE_OpAddInput(op.get(), bias_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(value_attr_T_value_tensor_h, TFE_TensorHandle, value, 0);
  const TF_DataType value_attr_T = TFE_TensorHandleDataType(value_attr_T_value_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", value_attr_T);

  REQUIRE_HANDLE(value_attr_T_bias_tensor_h, TFE_TensorHandle, bias, 0);
  const TF_DataType bias_attr_T = TFE_TensorHandleDataType(value_attr_T_bias_tensor_h);
  if (value_attr_T != bias_attr_T) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'bias' of 'biasAdd' op with data type '"
          << bias_attr_T
          << "' must match data type '"
          << value_attr_T
          << "' of argument 'value'";
      throw_exception(env, jvm_illegal_argument_exception, error_msg.str().c_str());
  }

  jbyte *data_format_c_value = env->GetByteArrayElements(data_format, nullptr);
  TFE_OpSetAttrString(op.get(), "data_format", reinterpret_cast<const char *>(data_format_c_value));
  env->ReleaseByteArrayElements(data_format, data_format_c_value, JNI_ABORT);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_relu(
    JNIEnv* env, jobject object, jlong context_handle, jlong features) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Relu", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(features_tensor_handle, TFE_TensorHandle, features, 0);
  TFE_OpAddInput(op.get(), features_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(features_attr_T_features_tensor_h, TFE_TensorHandle, features, 0);
  const TF_DataType features_attr_T = TFE_TensorHandleDataType(features_attr_T_features_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", features_attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_relu6(
    JNIEnv* env, jobject object, jlong context_handle, jlong features) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Relu6", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(features_tensor_handle, TFE_TensorHandle, features, 0);
  TFE_OpAddInput(op.get(), features_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(features_attr_T_features_tensor_h, TFE_TensorHandle, features, 0);
  const TF_DataType features_attr_T = TFE_TensorHandleDataType(features_attr_T_features_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", features_attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_elu(
    JNIEnv* env, jobject object, jlong context_handle, jlong features) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Elu", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(features_tensor_handle, TFE_TensorHandle, features, 0);
  TFE_OpAddInput(op.get(), features_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(features_attr_T_features_tensor_h, TFE_TensorHandle, features, 0);
  const TF_DataType features_attr_T = TFE_TensorHandleDataType(features_attr_T_features_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", features_attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_selu(
    JNIEnv* env, jobject object, jlong context_handle, jlong features) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Selu", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(features_tensor_handle, TFE_TensorHandle, features, 0);
  TFE_OpAddInput(op.get(), features_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(features_attr_T_features_tensor_h, TFE_TensorHandle, features, 0);
  const TF_DataType features_attr_T = TFE_TensorHandleDataType(features_attr_T_features_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", features_attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_softplus(
    JNIEnv* env, jobject object, jlong context_handle, jlong features) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Softplus", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(features_tensor_handle, TFE_TensorHandle, features, 0);
  TFE_OpAddInput(op.get(), features_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(features_attr_T_features_tensor_h, TFE_TensorHandle, features, 0);
  const TF_DataType features_attr_T = TFE_TensorHandleDataType(features_attr_T_features_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", features_attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_softsign(
    JNIEnv* env, jobject object, jlong context_handle, jlong features) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Softsign", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(features_tensor_handle, TFE_TensorHandle, features, 0);
  TFE_OpAddInput(op.get(), features_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(features_attr_T_features_tensor_h, TFE_TensorHandle, features, 0);
  const TF_DataType features_attr_T = TFE_TensorHandleDataType(features_attr_T_features_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", features_attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_softmax(
    JNIEnv* env, jobject object, jlong context_handle, jlong logits) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Softmax", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(logits_tensor_handle, TFE_TensorHandle, logits, 0);
  TFE_OpAddInput(op.get(), logits_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(logits_attr_T_logits_tensor_h, TFE_TensorHandle, logits, 0);
  const TF_DataType logits_attr_T = TFE_TensorHandleDataType(logits_attr_T_logits_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", logits_attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_logSoftmax(
    JNIEnv* env, jobject object, jlong context_handle, jlong logits) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "LogSoftmax", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(logits_tensor_handle, TFE_TensorHandle, logits, 0);
  TFE_OpAddInput(op.get(), logits_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(logits_attr_T_logits_tensor_h, TFE_TensorHandle, logits, 0);
  const TF_DataType logits_attr_T = TFE_TensorHandleDataType(logits_attr_T_logits_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", logits_attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_l2Loss(
    JNIEnv* env, jobject object, jlong context_handle, jlong t) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "L2Loss", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(t_tensor_handle, TFE_TensorHandle, t, 0);
  TFE_OpAddInput(op.get(), t_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(t_attr_T_t_tensor_h, TFE_TensorHandle, t, 0);
  const TF_DataType t_attr_T = TFE_TensorHandleDataType(t_attr_T_t_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", t_attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_softmaxCrossEntropyWithLogits(
    JNIEnv* env, jobject object, jlong context_handle, jlong features, jlong labels) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "SoftmaxCrossEntropyWithLogits", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(features_tensor_handle, TFE_TensorHandle, features, nullptr);
  TFE_OpAddInput(op.get(), features_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(labels_tensor_handle, TFE_TensorHandle, labels, nullptr);
  TFE_OpAddInput(op.get(), labels_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(features_attr_T_features_tensor_h, TFE_TensorHandle, features, nullptr);
  const TF_DataType features_attr_T = TFE_TensorHandleDataType(features_attr_T_features_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", features_attr_T);

  REQUIRE_HANDLE(features_attr_T_labels_tensor_h, TFE_TensorHandle, labels, nullptr);
  const TF_DataType labels_attr_T = TFE_TensorHandleDataType(features_attr_T_labels_tensor_h);
  if (features_attr_T != labels_attr_T) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'labels' of 'softmaxCrossEntropyWithLogits' op with data type '"
          << labels_attr_T
          << "' must match data type '"
          << features_attr_T
          << "' of argument 'features'";
      throw_exception(env, jvm_illegal_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 2;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, JNI_COMMIT);
  return outputs_array;
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_sparseSoftmaxCrossEntropyWithLogits(
    JNIEnv* env, jobject object, jlong context_handle, jlong features, jlong labels) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "SparseSoftmaxCrossEntropyWithLogits", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(features_tensor_handle, TFE_TensorHandle, features, nullptr);
  TFE_OpAddInput(op.get(), features_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(labels_tensor_handle, TFE_TensorHandle, labels, nullptr);
  TFE_OpAddInput(op.get(), labels_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(features_attr_T_features_tensor_h, TFE_TensorHandle, features, nullptr);
  const TF_DataType features_attr_T = TFE_TensorHandleDataType(features_attr_T_features_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", features_attr_T);

  REQUIRE_HANDLE(labels_attr_Tlabels_labels_tensor_h, TFE_TensorHandle, labels, nullptr);
  const TF_DataType labels_attr_Tlabels = TFE_TensorHandleDataType(labels_attr_Tlabels_labels_tensor_h);
  TFE_OpSetAttrType(op.get(), "Tlabels", labels_attr_Tlabels);

  const int num_outputs = 2;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, JNI_COMMIT);
  return outputs_array;
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_topKV2(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong k, jboolean sorted) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "TopKV2", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(input_tensor_handle, TFE_TensorHandle, input, nullptr);
  TFE_OpAddInput(op.get(), input_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(k_tensor_handle, TFE_TensorHandle, k, nullptr);
  TFE_OpAddInput(op.get(), k_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(input_attr_T_input_tensor_h, TFE_TensorHandle, input, nullptr);
  const TF_DataType input_attr_T = TFE_TensorHandleDataType(input_attr_T_input_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", input_attr_T);

  TFE_OpSetAttrBool(op.get(), "sorted", static_cast<unsigned char>(sorted));

  const int num_outputs = 2;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, JNI_COMMIT);
  return outputs_array;
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_inTopKV2(
    JNIEnv* env, jobject object, jlong context_handle, jlong predictions, jlong targets, jlong k) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "InTopKV2", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(predictions_tensor_handle, TFE_TensorHandle, predictions, 0);
  TFE_OpAddInput(op.get(), predictions_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(targets_tensor_handle, TFE_TensorHandle, targets, 0);
  TFE_OpAddInput(op.get(), targets_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(k_tensor_handle, TFE_TensorHandle, k, 0);
  TFE_OpAddInput(op.get(), k_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(targets_attr_T_targets_tensor_h, TFE_TensorHandle, targets, 0);
  const TF_DataType targets_attr_T = TFE_TensorHandleDataType(targets_attr_T_targets_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", targets_attr_T);

  REQUIRE_HANDLE(targets_attr_T_k_tensor_h, TFE_TensorHandle, k, 0);
  const TF_DataType k_attr_T = TFE_TensorHandleDataType(targets_attr_T_k_tensor_h);
  if (targets_attr_T != k_attr_T) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'k' of 'inTopKV2' op with data type '"
          << k_attr_T
          << "' must match data type '"
          << targets_attr_T
          << "' of argument 'targets'";
      throw_exception(env, jvm_illegal_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_avgPool(
    JNIEnv* env, jobject object, jlong context_handle, jlong value, jlongArray ksize, jlongArray strides, jbyteArray padding, jbyteArray data_format) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "AvgPool", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(value_tensor_handle, TFE_TensorHandle, value, 0);
  TFE_OpAddInput(op.get(), value_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(value_attr_T_value_tensor_h, TFE_TensorHandle, value, 0);
  const TF_DataType value_attr_T = TFE_TensorHandleDataType(value_attr_T_value_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", value_attr_T);

  const int ksize_n = env->GetArrayLength(ksize);
  std::unique_ptr<int64_t[]> ksize_c_value(new int64_t[ksize_n]);
  jlong* ksize_elems = env->GetLongArrayElements(ksize, nullptr);
  for (int i = 0; i < ksize_n; ++i) {
    ksize_c_value[i] = static_cast<int64_t>(ksize_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "ksize", ksize_c_value.get(), ksize_n);
  env->ReleaseLongArrayElements(ksize, ksize_elems, JNI_ABORT);

  const int strides_n = env->GetArrayLength(strides);
  std::unique_ptr<int64_t[]> strides_c_value(new int64_t[strides_n]);
  jlong* strides_elems = env->GetLongArrayElements(strides, nullptr);
  for (int i = 0; i < strides_n; ++i) {
    strides_c_value[i] = static_cast<int64_t>(strides_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "strides", strides_c_value.get(), strides_n);
  env->ReleaseLongArrayElements(strides, strides_elems, JNI_ABORT);

  jbyte *padding_c_value = env->GetByteArrayElements(padding, nullptr);
  TFE_OpSetAttrString(op.get(), "padding", reinterpret_cast<const char *>(padding_c_value));
  env->ReleaseByteArrayElements(padding, padding_c_value, JNI_ABORT);

  jbyte *data_format_c_value = env->GetByteArrayElements(data_format, nullptr);
  TFE_OpSetAttrString(op.get(), "data_format", reinterpret_cast<const char *>(data_format_c_value));
  env->ReleaseByteArrayElements(data_format, data_format_c_value, JNI_ABORT);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_avgPool3D(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlongArray ksize, jlongArray strides, jbyteArray padding, jbyteArray data_format) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "AvgPool3D", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_tensor_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_attr_T_input_tensor_h, TFE_TensorHandle, input, 0);
  const TF_DataType input_attr_T = TFE_TensorHandleDataType(input_attr_T_input_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", input_attr_T);

  const int ksize_n = env->GetArrayLength(ksize);
  std::unique_ptr<int64_t[]> ksize_c_value(new int64_t[ksize_n]);
  jlong* ksize_elems = env->GetLongArrayElements(ksize, nullptr);
  for (int i = 0; i < ksize_n; ++i) {
    ksize_c_value[i] = static_cast<int64_t>(ksize_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "ksize", ksize_c_value.get(), ksize_n);
  env->ReleaseLongArrayElements(ksize, ksize_elems, JNI_ABORT);

  const int strides_n = env->GetArrayLength(strides);
  std::unique_ptr<int64_t[]> strides_c_value(new int64_t[strides_n]);
  jlong* strides_elems = env->GetLongArrayElements(strides, nullptr);
  for (int i = 0; i < strides_n; ++i) {
    strides_c_value[i] = static_cast<int64_t>(strides_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "strides", strides_c_value.get(), strides_n);
  env->ReleaseLongArrayElements(strides, strides_elems, JNI_ABORT);

  jbyte *padding_c_value = env->GetByteArrayElements(padding, nullptr);
  TFE_OpSetAttrString(op.get(), "padding", reinterpret_cast<const char *>(padding_c_value));
  env->ReleaseByteArrayElements(padding, padding_c_value, JNI_ABORT);

  jbyte *data_format_c_value = env->GetByteArrayElements(data_format, nullptr);
  TFE_OpSetAttrString(op.get(), "data_format", reinterpret_cast<const char *>(data_format_c_value));
  env->ReleaseByteArrayElements(data_format, data_format_c_value, JNI_ABORT);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_maxPoolV2(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong ksize, jlong strides, jbyteArray padding, jbyteArray data_format) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "MaxPoolV2", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_tensor_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(ksize_tensor_handle, TFE_TensorHandle, ksize, 0);
  TFE_OpAddInput(op.get(), ksize_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(strides_tensor_handle, TFE_TensorHandle, strides, 0);
  TFE_OpAddInput(op.get(), strides_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_attr_T_input_tensor_h, TFE_TensorHandle, input, 0);
  const TF_DataType input_attr_T = TFE_TensorHandleDataType(input_attr_T_input_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", input_attr_T);

  jbyte *padding_c_value = env->GetByteArrayElements(padding, nullptr);
  TFE_OpSetAttrString(op.get(), "padding", reinterpret_cast<const char *>(padding_c_value));
  env->ReleaseByteArrayElements(padding, padding_c_value, JNI_ABORT);

  jbyte *data_format_c_value = env->GetByteArrayElements(data_format, nullptr);
  TFE_OpSetAttrString(op.get(), "data_format", reinterpret_cast<const char *>(data_format_c_value));
  env->ReleaseByteArrayElements(data_format, data_format_c_value, JNI_ABORT);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_maxPool3D(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlongArray ksize, jlongArray strides, jbyteArray padding, jbyteArray data_format) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "MaxPool3D", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_tensor_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_attr_T_input_tensor_h, TFE_TensorHandle, input, 0);
  const TF_DataType input_attr_T = TFE_TensorHandleDataType(input_attr_T_input_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", input_attr_T);

  const int ksize_n = env->GetArrayLength(ksize);
  std::unique_ptr<int64_t[]> ksize_c_value(new int64_t[ksize_n]);
  jlong* ksize_elems = env->GetLongArrayElements(ksize, nullptr);
  for (int i = 0; i < ksize_n; ++i) {
    ksize_c_value[i] = static_cast<int64_t>(ksize_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "ksize", ksize_c_value.get(), ksize_n);
  env->ReleaseLongArrayElements(ksize, ksize_elems, JNI_ABORT);

  const int strides_n = env->GetArrayLength(strides);
  std::unique_ptr<int64_t[]> strides_c_value(new int64_t[strides_n]);
  jlong* strides_elems = env->GetLongArrayElements(strides, nullptr);
  for (int i = 0; i < strides_n; ++i) {
    strides_c_value[i] = static_cast<int64_t>(strides_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "strides", strides_c_value.get(), strides_n);
  env->ReleaseLongArrayElements(strides, strides_elems, JNI_ABORT);

  jbyte *padding_c_value = env->GetByteArrayElements(padding, nullptr);
  TFE_OpSetAttrString(op.get(), "padding", reinterpret_cast<const char *>(padding_c_value));
  env->ReleaseByteArrayElements(padding, padding_c_value, JNI_ABORT);

  jbyte *data_format_c_value = env->GetByteArrayElements(data_format, nullptr);
  TFE_OpSetAttrString(op.get(), "data_format", reinterpret_cast<const char *>(data_format_c_value));
  env->ReleaseByteArrayElements(data_format, data_format_c_value, JNI_ABORT);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_maxPoolWithArgmax(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlongArray ksize, jlongArray strides, jbyteArray padding, jint targmax) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "MaxPoolWithArgmax", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(input_tensor_handle, TFE_TensorHandle, input, nullptr);
  TFE_OpAddInput(op.get(), input_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(input_attr_T_input_tensor_h, TFE_TensorHandle, input, nullptr);
  const TF_DataType input_attr_T = TFE_TensorHandleDataType(input_attr_T_input_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", input_attr_T);

  const int ksize_n = env->GetArrayLength(ksize);
  std::unique_ptr<int64_t[]> ksize_c_value(new int64_t[ksize_n]);
  jlong* ksize_elems = env->GetLongArrayElements(ksize, nullptr);
  for (int i = 0; i < ksize_n; ++i) {
    ksize_c_value[i] = static_cast<int64_t>(ksize_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "ksize", ksize_c_value.get(), ksize_n);
  env->ReleaseLongArrayElements(ksize, ksize_elems, JNI_ABORT);

  const int strides_n = env->GetArrayLength(strides);
  std::unique_ptr<int64_t[]> strides_c_value(new int64_t[strides_n]);
  jlong* strides_elems = env->GetLongArrayElements(strides, nullptr);
  for (int i = 0; i < strides_n; ++i) {
    strides_c_value[i] = static_cast<int64_t>(strides_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "strides", strides_c_value.get(), strides_n);
  env->ReleaseLongArrayElements(strides, strides_elems, JNI_ABORT);

  jbyte *padding_c_value = env->GetByteArrayElements(padding, nullptr);
  TFE_OpSetAttrString(op.get(), "padding", reinterpret_cast<const char *>(padding_c_value));
  env->ReleaseByteArrayElements(padding, padding_c_value, JNI_ABORT);

  TFE_OpSetAttrType(op.get(), "Targmax", static_cast<TF_DataType>(targmax));

  const int num_outputs = 2;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, JNI_COMMIT);
  return outputs_array;
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_fractionalAvgPool(
    JNIEnv* env, jobject object, jlong context_handle, jlong value, jfloatArray pooling_ratio, jboolean pseudo_random, jboolean overlapping, jboolean deterministic, jlong seed, jlong seed2) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "FractionalAvgPool", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(value_tensor_handle, TFE_TensorHandle, value, nullptr);
  TFE_OpAddInput(op.get(), value_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(value_attr_T_value_tensor_h, TFE_TensorHandle, value, nullptr);
  const TF_DataType value_attr_T = TFE_TensorHandleDataType(value_attr_T_value_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", value_attr_T);

  const int pooling_ratio_n = env->GetArrayLength(pooling_ratio);
  std::unique_ptr<float[]> pooling_ratio_c_value(new float[pooling_ratio_n]);
  jfloat* pooling_ratio_elems = env->GetFloatArrayElements(pooling_ratio, nullptr);
  for (int i = 0; i < pooling_ratio_n; ++i) {
    pooling_ratio_c_value[i] = static_cast<float>(pooling_ratio_elems[i]);
  }
  TFE_OpSetAttrFloatList(op.get(), "pooling_ratio", pooling_ratio_c_value.get(), pooling_ratio_n);
  env->ReleaseFloatArrayElements(pooling_ratio, pooling_ratio_elems, JNI_ABORT);

  TFE_OpSetAttrBool(op.get(), "pseudo_random", static_cast<unsigned char>(pseudo_random));

  TFE_OpSetAttrBool(op.get(), "overlapping", static_cast<unsigned char>(overlapping));

  TFE_OpSetAttrBool(op.get(), "deterministic", static_cast<unsigned char>(deterministic));

  TFE_OpSetAttrInt(op.get(), "seed", static_cast<int64_t>(seed));

  TFE_OpSetAttrInt(op.get(), "seed2", static_cast<int64_t>(seed2));

  const int num_outputs = 3;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, JNI_COMMIT);
  return outputs_array;
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_fractionalMaxPool(
    JNIEnv* env, jobject object, jlong context_handle, jlong value, jfloatArray pooling_ratio, jboolean pseudo_random, jboolean overlapping, jboolean deterministic, jlong seed, jlong seed2) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "FractionalMaxPool", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(value_tensor_handle, TFE_TensorHandle, value, nullptr);
  TFE_OpAddInput(op.get(), value_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(value_attr_T_value_tensor_h, TFE_TensorHandle, value, nullptr);
  const TF_DataType value_attr_T = TFE_TensorHandleDataType(value_attr_T_value_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", value_attr_T);

  const int pooling_ratio_n = env->GetArrayLength(pooling_ratio);
  std::unique_ptr<float[]> pooling_ratio_c_value(new float[pooling_ratio_n]);
  jfloat* pooling_ratio_elems = env->GetFloatArrayElements(pooling_ratio, nullptr);
  for (int i = 0; i < pooling_ratio_n; ++i) {
    pooling_ratio_c_value[i] = static_cast<float>(pooling_ratio_elems[i]);
  }
  TFE_OpSetAttrFloatList(op.get(), "pooling_ratio", pooling_ratio_c_value.get(), pooling_ratio_n);
  env->ReleaseFloatArrayElements(pooling_ratio, pooling_ratio_elems, JNI_ABORT);

  TFE_OpSetAttrBool(op.get(), "pseudo_random", static_cast<unsigned char>(pseudo_random));

  TFE_OpSetAttrBool(op.get(), "overlapping", static_cast<unsigned char>(overlapping));

  TFE_OpSetAttrBool(op.get(), "deterministic", static_cast<unsigned char>(deterministic));

  TFE_OpSetAttrInt(op.get(), "seed", static_cast<int64_t>(seed));

  TFE_OpSetAttrInt(op.get(), "seed2", static_cast<int64_t>(seed2));

  const int num_outputs = 3;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, JNI_COMMIT);
  return outputs_array;
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_conv2D(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong filter, jlongArray strides, jbyteArray padding, jboolean use_cudnn_on_gpu, jbyteArray data_format) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Conv2D", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_tensor_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(filter_tensor_handle, TFE_TensorHandle, filter, 0);
  TFE_OpAddInput(op.get(), filter_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_attr_T_input_tensor_h, TFE_TensorHandle, input, 0);
  const TF_DataType input_attr_T = TFE_TensorHandleDataType(input_attr_T_input_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", input_attr_T);

  REQUIRE_HANDLE(input_attr_T_filter_tensor_h, TFE_TensorHandle, filter, 0);
  const TF_DataType filter_attr_T = TFE_TensorHandleDataType(input_attr_T_filter_tensor_h);
  if (input_attr_T != filter_attr_T) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'filter' of 'conv2D' op with data type '"
          << filter_attr_T
          << "' must match data type '"
          << input_attr_T
          << "' of argument 'input'";
      throw_exception(env, jvm_illegal_argument_exception, error_msg.str().c_str());
  }

  const int strides_n = env->GetArrayLength(strides);
  std::unique_ptr<int64_t[]> strides_c_value(new int64_t[strides_n]);
  jlong* strides_elems = env->GetLongArrayElements(strides, nullptr);
  for (int i = 0; i < strides_n; ++i) {
    strides_c_value[i] = static_cast<int64_t>(strides_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "strides", strides_c_value.get(), strides_n);
  env->ReleaseLongArrayElements(strides, strides_elems, JNI_ABORT);

  jbyte *padding_c_value = env->GetByteArrayElements(padding, nullptr);
  TFE_OpSetAttrString(op.get(), "padding", reinterpret_cast<const char *>(padding_c_value));
  env->ReleaseByteArrayElements(padding, padding_c_value, JNI_ABORT);

  TFE_OpSetAttrBool(op.get(), "use_cudnn_on_gpu", static_cast<unsigned char>(use_cudnn_on_gpu));

  jbyte *data_format_c_value = env->GetByteArrayElements(data_format, nullptr);
  TFE_OpSetAttrString(op.get(), "data_format", reinterpret_cast<const char *>(data_format_c_value));
  env->ReleaseByteArrayElements(data_format, data_format_c_value, JNI_ABORT);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_fusedResizeAndPadConv2D(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong size, jlong paddings, jlong filter, jbyteArray mode, jlongArray strides, jbyteArray padding, jboolean resize_align_corners) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "FusedResizeAndPadConv2D", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_tensor_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(size_tensor_handle, TFE_TensorHandle, size, 0);
  TFE_OpAddInput(op.get(), size_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(paddings_tensor_handle, TFE_TensorHandle, paddings, 0);
  TFE_OpAddInput(op.get(), paddings_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(filter_tensor_handle, TFE_TensorHandle, filter, 0);
  TFE_OpAddInput(op.get(), filter_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_attr_T_input_tensor_h, TFE_TensorHandle, input, 0);
  const TF_DataType input_attr_T = TFE_TensorHandleDataType(input_attr_T_input_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", input_attr_T);

  REQUIRE_HANDLE(input_attr_T_filter_tensor_h, TFE_TensorHandle, filter, 0);
  const TF_DataType filter_attr_T = TFE_TensorHandleDataType(input_attr_T_filter_tensor_h);
  if (input_attr_T != filter_attr_T) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'filter' of 'fusedResizeAndPadConv2D' op with data type '"
          << filter_attr_T
          << "' must match data type '"
          << input_attr_T
          << "' of argument 'input'";
      throw_exception(env, jvm_illegal_argument_exception, error_msg.str().c_str());
  }

  jbyte *mode_c_value = env->GetByteArrayElements(mode, nullptr);
  TFE_OpSetAttrString(op.get(), "mode", reinterpret_cast<const char *>(mode_c_value));
  env->ReleaseByteArrayElements(mode, mode_c_value, JNI_ABORT);

  const int strides_n = env->GetArrayLength(strides);
  std::unique_ptr<int64_t[]> strides_c_value(new int64_t[strides_n]);
  jlong* strides_elems = env->GetLongArrayElements(strides, nullptr);
  for (int i = 0; i < strides_n; ++i) {
    strides_c_value[i] = static_cast<int64_t>(strides_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "strides", strides_c_value.get(), strides_n);
  env->ReleaseLongArrayElements(strides, strides_elems, JNI_ABORT);

  jbyte *padding_c_value = env->GetByteArrayElements(padding, nullptr);
  TFE_OpSetAttrString(op.get(), "padding", reinterpret_cast<const char *>(padding_c_value));
  env->ReleaseByteArrayElements(padding, padding_c_value, JNI_ABORT);

  TFE_OpSetAttrBool(op.get(), "resize_align_corners", static_cast<unsigned char>(resize_align_corners));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_fusedPadConv2D(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong paddings, jlong filter, jbyteArray mode, jlongArray strides, jbyteArray padding) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "FusedPadConv2D", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_tensor_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(paddings_tensor_handle, TFE_TensorHandle, paddings, 0);
  TFE_OpAddInput(op.get(), paddings_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(filter_tensor_handle, TFE_TensorHandle, filter, 0);
  TFE_OpAddInput(op.get(), filter_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_attr_T_input_tensor_h, TFE_TensorHandle, input, 0);
  const TF_DataType input_attr_T = TFE_TensorHandleDataType(input_attr_T_input_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", input_attr_T);

  REQUIRE_HANDLE(input_attr_T_filter_tensor_h, TFE_TensorHandle, filter, 0);
  const TF_DataType filter_attr_T = TFE_TensorHandleDataType(input_attr_T_filter_tensor_h);
  if (input_attr_T != filter_attr_T) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'filter' of 'fusedPadConv2D' op with data type '"
          << filter_attr_T
          << "' must match data type '"
          << input_attr_T
          << "' of argument 'input'";
      throw_exception(env, jvm_illegal_argument_exception, error_msg.str().c_str());
  }

  jbyte *mode_c_value = env->GetByteArrayElements(mode, nullptr);
  TFE_OpSetAttrString(op.get(), "mode", reinterpret_cast<const char *>(mode_c_value));
  env->ReleaseByteArrayElements(mode, mode_c_value, JNI_ABORT);

  const int strides_n = env->GetArrayLength(strides);
  std::unique_ptr<int64_t[]> strides_c_value(new int64_t[strides_n]);
  jlong* strides_elems = env->GetLongArrayElements(strides, nullptr);
  for (int i = 0; i < strides_n; ++i) {
    strides_c_value[i] = static_cast<int64_t>(strides_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "strides", strides_c_value.get(), strides_n);
  env->ReleaseLongArrayElements(strides, strides_elems, JNI_ABORT);

  jbyte *padding_c_value = env->GetByteArrayElements(padding, nullptr);
  TFE_OpSetAttrString(op.get(), "padding", reinterpret_cast<const char *>(padding_c_value));
  env->ReleaseByteArrayElements(padding, padding_c_value, JNI_ABORT);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_depthwiseConv2dNative(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong filter, jlongArray strides, jbyteArray padding, jbyteArray data_format) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "DepthwiseConv2dNative", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_tensor_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(filter_tensor_handle, TFE_TensorHandle, filter, 0);
  TFE_OpAddInput(op.get(), filter_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_attr_T_input_tensor_h, TFE_TensorHandle, input, 0);
  const TF_DataType input_attr_T = TFE_TensorHandleDataType(input_attr_T_input_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", input_attr_T);

  REQUIRE_HANDLE(input_attr_T_filter_tensor_h, TFE_TensorHandle, filter, 0);
  const TF_DataType filter_attr_T = TFE_TensorHandleDataType(input_attr_T_filter_tensor_h);
  if (input_attr_T != filter_attr_T) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'filter' of 'depthwiseConv2dNative' op with data type '"
          << filter_attr_T
          << "' must match data type '"
          << input_attr_T
          << "' of argument 'input'";
      throw_exception(env, jvm_illegal_argument_exception, error_msg.str().c_str());
  }

  const int strides_n = env->GetArrayLength(strides);
  std::unique_ptr<int64_t[]> strides_c_value(new int64_t[strides_n]);
  jlong* strides_elems = env->GetLongArrayElements(strides, nullptr);
  for (int i = 0; i < strides_n; ++i) {
    strides_c_value[i] = static_cast<int64_t>(strides_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "strides", strides_c_value.get(), strides_n);
  env->ReleaseLongArrayElements(strides, strides_elems, JNI_ABORT);

  jbyte *padding_c_value = env->GetByteArrayElements(padding, nullptr);
  TFE_OpSetAttrString(op.get(), "padding", reinterpret_cast<const char *>(padding_c_value));
  env->ReleaseByteArrayElements(padding, padding_c_value, JNI_ABORT);

  jbyte *data_format_c_value = env->GetByteArrayElements(data_format, nullptr);
  TFE_OpSetAttrString(op.get(), "data_format", reinterpret_cast<const char *>(data_format_c_value));
  env->ReleaseByteArrayElements(data_format, data_format_c_value, JNI_ABORT);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_conv3D(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong filter, jlongArray strides, jbyteArray padding, jbyteArray data_format) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Conv3D", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_tensor_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(filter_tensor_handle, TFE_TensorHandle, filter, 0);
  TFE_OpAddInput(op.get(), filter_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_attr_T_input_tensor_h, TFE_TensorHandle, input, 0);
  const TF_DataType input_attr_T = TFE_TensorHandleDataType(input_attr_T_input_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", input_attr_T);

  REQUIRE_HANDLE(input_attr_T_filter_tensor_h, TFE_TensorHandle, filter, 0);
  const TF_DataType filter_attr_T = TFE_TensorHandleDataType(input_attr_T_filter_tensor_h);
  if (input_attr_T != filter_attr_T) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'filter' of 'conv3D' op with data type '"
          << filter_attr_T
          << "' must match data type '"
          << input_attr_T
          << "' of argument 'input'";
      throw_exception(env, jvm_illegal_argument_exception, error_msg.str().c_str());
  }

  const int strides_n = env->GetArrayLength(strides);
  std::unique_ptr<int64_t[]> strides_c_value(new int64_t[strides_n]);
  jlong* strides_elems = env->GetLongArrayElements(strides, nullptr);
  for (int i = 0; i < strides_n; ++i) {
    strides_c_value[i] = static_cast<int64_t>(strides_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "strides", strides_c_value.get(), strides_n);
  env->ReleaseLongArrayElements(strides, strides_elems, JNI_ABORT);

  jbyte *padding_c_value = env->GetByteArrayElements(padding, nullptr);
  TFE_OpSetAttrString(op.get(), "padding", reinterpret_cast<const char *>(padding_c_value));
  env->ReleaseByteArrayElements(padding, padding_c_value, JNI_ABORT);

  jbyte *data_format_c_value = env->GetByteArrayElements(data_format, nullptr);
  TFE_OpSetAttrString(op.get(), "data_format", reinterpret_cast<const char *>(data_format_c_value));
  env->ReleaseByteArrayElements(data_format, data_format_c_value, JNI_ABORT);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_dilation2D(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong filter, jlongArray strides, jlongArray rates, jbyteArray padding) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Dilation2D", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_tensor_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(filter_tensor_handle, TFE_TensorHandle, filter, 0);
  TFE_OpAddInput(op.get(), filter_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_attr_T_input_tensor_h, TFE_TensorHandle, input, 0);
  const TF_DataType input_attr_T = TFE_TensorHandleDataType(input_attr_T_input_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", input_attr_T);

  REQUIRE_HANDLE(input_attr_T_filter_tensor_h, TFE_TensorHandle, filter, 0);
  const TF_DataType filter_attr_T = TFE_TensorHandleDataType(input_attr_T_filter_tensor_h);
  if (input_attr_T != filter_attr_T) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'filter' of 'dilation2D' op with data type '"
          << filter_attr_T
          << "' must match data type '"
          << input_attr_T
          << "' of argument 'input'";
      throw_exception(env, jvm_illegal_argument_exception, error_msg.str().c_str());
  }

  const int strides_n = env->GetArrayLength(strides);
  std::unique_ptr<int64_t[]> strides_c_value(new int64_t[strides_n]);
  jlong* strides_elems = env->GetLongArrayElements(strides, nullptr);
  for (int i = 0; i < strides_n; ++i) {
    strides_c_value[i] = static_cast<int64_t>(strides_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "strides", strides_c_value.get(), strides_n);
  env->ReleaseLongArrayElements(strides, strides_elems, JNI_ABORT);

  const int rates_n = env->GetArrayLength(rates);
  std::unique_ptr<int64_t[]> rates_c_value(new int64_t[rates_n]);
  jlong* rates_elems = env->GetLongArrayElements(rates, nullptr);
  for (int i = 0; i < rates_n; ++i) {
    rates_c_value[i] = static_cast<int64_t>(rates_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "rates", rates_c_value.get(), rates_n);
  env->ReleaseLongArrayElements(rates, rates_elems, JNI_ABORT);

  jbyte *padding_c_value = env->GetByteArrayElements(padding, nullptr);
  TFE_OpSetAttrString(op.get(), "padding", reinterpret_cast<const char *>(padding_c_value));
  env->ReleaseByteArrayElements(padding, padding_c_value, JNI_ABORT);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_lRN(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong depth_radius, jfloat bias, jfloat alpha, jfloat beta) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "LRN", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_tensor_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_attr_T_input_tensor_h, TFE_TensorHandle, input, 0);
  const TF_DataType input_attr_T = TFE_TensorHandleDataType(input_attr_T_input_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", input_attr_T);

  TFE_OpSetAttrInt(op.get(), "depth_radius", static_cast<int64_t>(depth_radius));

  TFE_OpSetAttrFloat(op.get(), "bias", static_cast<float>(bias));

  TFE_OpSetAttrFloat(op.get(), "alpha", static_cast<float>(alpha));

  TFE_OpSetAttrFloat(op.get(), "beta", static_cast<float>(beta));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_batchNormWithGlobalNormalization(
    JNIEnv* env, jobject object, jlong context_handle, jlong t, jlong m, jlong v, jlong beta, jlong gamma, jfloat variance_epsilon, jboolean scale_after_normalization) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "BatchNormWithGlobalNormalization", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(t_tensor_handle, TFE_TensorHandle, t, 0);
  TFE_OpAddInput(op.get(), t_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(m_tensor_handle, TFE_TensorHandle, m, 0);
  TFE_OpAddInput(op.get(), m_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(v_tensor_handle, TFE_TensorHandle, v, 0);
  TFE_OpAddInput(op.get(), v_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(beta_tensor_handle, TFE_TensorHandle, beta, 0);
  TFE_OpAddInput(op.get(), beta_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(gamma_tensor_handle, TFE_TensorHandle, gamma, 0);
  TFE_OpAddInput(op.get(), gamma_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(t_attr_T_t_tensor_h, TFE_TensorHandle, t, 0);
  const TF_DataType t_attr_T = TFE_TensorHandleDataType(t_attr_T_t_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", t_attr_T);

  REQUIRE_HANDLE(t_attr_T_m_tensor_h, TFE_TensorHandle, m, 0);
  const TF_DataType m_attr_T = TFE_TensorHandleDataType(t_attr_T_m_tensor_h);
  if (t_attr_T != m_attr_T) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'm' of 'batchNormWithGlobalNormalization' op with data type '"
          << m_attr_T
          << "' must match data type '"
          << t_attr_T
          << "' of argument 't'";
      throw_exception(env, jvm_illegal_argument_exception, error_msg.str().c_str());
  }

  REQUIRE_HANDLE(t_attr_T_v_tensor_h, TFE_TensorHandle, v, 0);
  const TF_DataType v_attr_T = TFE_TensorHandleDataType(t_attr_T_v_tensor_h);
  if (t_attr_T != v_attr_T) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'v' of 'batchNormWithGlobalNormalization' op with data type '"
          << v_attr_T
          << "' must match data type '"
          << t_attr_T
          << "' of argument 't'";
      throw_exception(env, jvm_illegal_argument_exception, error_msg.str().c_str());
  }

  REQUIRE_HANDLE(t_attr_T_beta_tensor_h, TFE_TensorHandle, beta, 0);
  const TF_DataType beta_attr_T = TFE_TensorHandleDataType(t_attr_T_beta_tensor_h);
  if (t_attr_T != beta_attr_T) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'beta' of 'batchNormWithGlobalNormalization' op with data type '"
          << beta_attr_T
          << "' must match data type '"
          << t_attr_T
          << "' of argument 't'";
      throw_exception(env, jvm_illegal_argument_exception, error_msg.str().c_str());
  }

  REQUIRE_HANDLE(t_attr_T_gamma_tensor_h, TFE_TensorHandle, gamma, 0);
  const TF_DataType gamma_attr_T = TFE_TensorHandleDataType(t_attr_T_gamma_tensor_h);
  if (t_attr_T != gamma_attr_T) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'gamma' of 'batchNormWithGlobalNormalization' op with data type '"
          << gamma_attr_T
          << "' must match data type '"
          << t_attr_T
          << "' of argument 't'";
      throw_exception(env, jvm_illegal_argument_exception, error_msg.str().c_str());
  }

  TFE_OpSetAttrFloat(op.get(), "variance_epsilon", static_cast<float>(variance_epsilon));

  TFE_OpSetAttrBool(op.get(), "scale_after_normalization", static_cast<unsigned char>(scale_after_normalization));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_fusedBatchNorm(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jlong scale, jlong offset, jlong mean, jlong variance, jfloat epsilon, jbyteArray data_format, jboolean is_training) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "FusedBatchNorm", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(x_tensor_handle, TFE_TensorHandle, x, nullptr);
  TFE_OpAddInput(op.get(), x_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(scale_tensor_handle, TFE_TensorHandle, scale, nullptr);
  TFE_OpAddInput(op.get(), scale_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(offset_tensor_handle, TFE_TensorHandle, offset, nullptr);
  TFE_OpAddInput(op.get(), offset_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(mean_tensor_handle, TFE_TensorHandle, mean, nullptr);
  TFE_OpAddInput(op.get(), mean_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(variance_tensor_handle, TFE_TensorHandle, variance, nullptr);
  TFE_OpAddInput(op.get(), variance_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(x_attr_T_x_tensor_h, TFE_TensorHandle, x, nullptr);
  const TF_DataType x_attr_T = TFE_TensorHandleDataType(x_attr_T_x_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", x_attr_T);

  REQUIRE_HANDLE(x_attr_T_scale_tensor_h, TFE_TensorHandle, scale, nullptr);
  const TF_DataType scale_attr_T = TFE_TensorHandleDataType(x_attr_T_scale_tensor_h);
  if (x_attr_T != scale_attr_T) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'scale' of 'fusedBatchNorm' op with data type '"
          << scale_attr_T
          << "' must match data type '"
          << x_attr_T
          << "' of argument 'x'";
      throw_exception(env, jvm_illegal_argument_exception, error_msg.str().c_str());
  }

  REQUIRE_HANDLE(x_attr_T_offset_tensor_h, TFE_TensorHandle, offset, nullptr);
  const TF_DataType offset_attr_T = TFE_TensorHandleDataType(x_attr_T_offset_tensor_h);
  if (x_attr_T != offset_attr_T) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'offset' of 'fusedBatchNorm' op with data type '"
          << offset_attr_T
          << "' must match data type '"
          << x_attr_T
          << "' of argument 'x'";
      throw_exception(env, jvm_illegal_argument_exception, error_msg.str().c_str());
  }

  REQUIRE_HANDLE(x_attr_T_mean_tensor_h, TFE_TensorHandle, mean, nullptr);
  const TF_DataType mean_attr_T = TFE_TensorHandleDataType(x_attr_T_mean_tensor_h);
  if (x_attr_T != mean_attr_T) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'mean' of 'fusedBatchNorm' op with data type '"
          << mean_attr_T
          << "' must match data type '"
          << x_attr_T
          << "' of argument 'x'";
      throw_exception(env, jvm_illegal_argument_exception, error_msg.str().c_str());
  }

  REQUIRE_HANDLE(x_attr_T_variance_tensor_h, TFE_TensorHandle, variance, nullptr);
  const TF_DataType variance_attr_T = TFE_TensorHandleDataType(x_attr_T_variance_tensor_h);
  if (x_attr_T != variance_attr_T) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'variance' of 'fusedBatchNorm' op with data type '"
          << variance_attr_T
          << "' must match data type '"
          << x_attr_T
          << "' of argument 'x'";
      throw_exception(env, jvm_illegal_argument_exception, error_msg.str().c_str());
  }

  TFE_OpSetAttrFloat(op.get(), "epsilon", static_cast<float>(epsilon));

  jbyte *data_format_c_value = env->GetByteArrayElements(data_format, nullptr);
  TFE_OpSetAttrString(op.get(), "data_format", reinterpret_cast<const char *>(data_format_c_value));
  env->ReleaseByteArrayElements(data_format, data_format_c_value, JNI_ABORT);

  TFE_OpSetAttrBool(op.get(), "is_training", static_cast<unsigned char>(is_training));

  const int num_outputs = 5;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, JNI_COMMIT);
  return outputs_array;
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_quantizedBiasAdd(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong bias, jlong min_input, jlong max_input, jlong min_bias, jlong max_bias, jint out_type) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "QuantizedBiasAdd", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(input_tensor_handle, TFE_TensorHandle, input, nullptr);
  TFE_OpAddInput(op.get(), input_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(bias_tensor_handle, TFE_TensorHandle, bias, nullptr);
  TFE_OpAddInput(op.get(), bias_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(min_input_tensor_handle, TFE_TensorHandle, min_input, nullptr);
  TFE_OpAddInput(op.get(), min_input_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(max_input_tensor_handle, TFE_TensorHandle, max_input, nullptr);
  TFE_OpAddInput(op.get(), max_input_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(min_bias_tensor_handle, TFE_TensorHandle, min_bias, nullptr);
  TFE_OpAddInput(op.get(), min_bias_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(max_bias_tensor_handle, TFE_TensorHandle, max_bias, nullptr);
  TFE_OpAddInput(op.get(), max_bias_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(input_attr_T1_input_tensor_h, TFE_TensorHandle, input, nullptr);
  const TF_DataType input_attr_T1 = TFE_TensorHandleDataType(input_attr_T1_input_tensor_h);
  TFE_OpSetAttrType(op.get(), "T1", input_attr_T1);

  REQUIRE_HANDLE(bias_attr_T2_bias_tensor_h, TFE_TensorHandle, bias, nullptr);
  const TF_DataType bias_attr_T2 = TFE_TensorHandleDataType(bias_attr_T2_bias_tensor_h);
  TFE_OpSetAttrType(op.get(), "T2", bias_attr_T2);

  TFE_OpSetAttrType(op.get(), "out_type", static_cast<TF_DataType>(out_type));

  const int num_outputs = 3;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, JNI_COMMIT);
  return outputs_array;
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_quantizedRelu(
    JNIEnv* env, jobject object, jlong context_handle, jlong features, jlong min_features, jlong max_features, jint out_type) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "QuantizedRelu", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(features_tensor_handle, TFE_TensorHandle, features, nullptr);
  TFE_OpAddInput(op.get(), features_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(min_features_tensor_handle, TFE_TensorHandle, min_features, nullptr);
  TFE_OpAddInput(op.get(), min_features_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(max_features_tensor_handle, TFE_TensorHandle, max_features, nullptr);
  TFE_OpAddInput(op.get(), max_features_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(features_attr_Tinput_features_tensor_h, TFE_TensorHandle, features, nullptr);
  const TF_DataType features_attr_Tinput = TFE_TensorHandleDataType(features_attr_Tinput_features_tensor_h);
  TFE_OpSetAttrType(op.get(), "Tinput", features_attr_Tinput);

  TFE_OpSetAttrType(op.get(), "out_type", static_cast<TF_DataType>(out_type));

  const int num_outputs = 3;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, JNI_COMMIT);
  return outputs_array;
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_quantizedRelu6(
    JNIEnv* env, jobject object, jlong context_handle, jlong features, jlong min_features, jlong max_features, jint out_type) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "QuantizedRelu6", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(features_tensor_handle, TFE_TensorHandle, features, nullptr);
  TFE_OpAddInput(op.get(), features_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(min_features_tensor_handle, TFE_TensorHandle, min_features, nullptr);
  TFE_OpAddInput(op.get(), min_features_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(max_features_tensor_handle, TFE_TensorHandle, max_features, nullptr);
  TFE_OpAddInput(op.get(), max_features_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(features_attr_Tinput_features_tensor_h, TFE_TensorHandle, features, nullptr);
  const TF_DataType features_attr_Tinput = TFE_TensorHandleDataType(features_attr_Tinput_features_tensor_h);
  TFE_OpSetAttrType(op.get(), "Tinput", features_attr_Tinput);

  TFE_OpSetAttrType(op.get(), "out_type", static_cast<TF_DataType>(out_type));

  const int num_outputs = 3;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, JNI_COMMIT);
  return outputs_array;
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_quantizedReluX(
    JNIEnv* env, jobject object, jlong context_handle, jlong features, jlong max_value, jlong min_features, jlong max_features, jint out_type) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "QuantizedReluX", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(features_tensor_handle, TFE_TensorHandle, features, nullptr);
  TFE_OpAddInput(op.get(), features_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(max_value_tensor_handle, TFE_TensorHandle, max_value, nullptr);
  TFE_OpAddInput(op.get(), max_value_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(min_features_tensor_handle, TFE_TensorHandle, min_features, nullptr);
  TFE_OpAddInput(op.get(), min_features_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(max_features_tensor_handle, TFE_TensorHandle, max_features, nullptr);
  TFE_OpAddInput(op.get(), max_features_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(features_attr_Tinput_features_tensor_h, TFE_TensorHandle, features, nullptr);
  const TF_DataType features_attr_Tinput = TFE_TensorHandleDataType(features_attr_Tinput_features_tensor_h);
  TFE_OpSetAttrType(op.get(), "Tinput", features_attr_Tinput);

  TFE_OpSetAttrType(op.get(), "out_type", static_cast<TF_DataType>(out_type));

  const int num_outputs = 3;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, JNI_COMMIT);
  return outputs_array;
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_quantizedAvgPool(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong min_input, jlong max_input, jlongArray ksize, jlongArray strides, jbyteArray padding) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "QuantizedAvgPool", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(input_tensor_handle, TFE_TensorHandle, input, nullptr);
  TFE_OpAddInput(op.get(), input_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(min_input_tensor_handle, TFE_TensorHandle, min_input, nullptr);
  TFE_OpAddInput(op.get(), min_input_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(max_input_tensor_handle, TFE_TensorHandle, max_input, nullptr);
  TFE_OpAddInput(op.get(), max_input_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(input_attr_T_input_tensor_h, TFE_TensorHandle, input, nullptr);
  const TF_DataType input_attr_T = TFE_TensorHandleDataType(input_attr_T_input_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", input_attr_T);

  const int ksize_n = env->GetArrayLength(ksize);
  std::unique_ptr<int64_t[]> ksize_c_value(new int64_t[ksize_n]);
  jlong* ksize_elems = env->GetLongArrayElements(ksize, nullptr);
  for (int i = 0; i < ksize_n; ++i) {
    ksize_c_value[i] = static_cast<int64_t>(ksize_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "ksize", ksize_c_value.get(), ksize_n);
  env->ReleaseLongArrayElements(ksize, ksize_elems, JNI_ABORT);

  const int strides_n = env->GetArrayLength(strides);
  std::unique_ptr<int64_t[]> strides_c_value(new int64_t[strides_n]);
  jlong* strides_elems = env->GetLongArrayElements(strides, nullptr);
  for (int i = 0; i < strides_n; ++i) {
    strides_c_value[i] = static_cast<int64_t>(strides_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "strides", strides_c_value.get(), strides_n);
  env->ReleaseLongArrayElements(strides, strides_elems, JNI_ABORT);

  jbyte *padding_c_value = env->GetByteArrayElements(padding, nullptr);
  TFE_OpSetAttrString(op.get(), "padding", reinterpret_cast<const char *>(padding_c_value));
  env->ReleaseByteArrayElements(padding, padding_c_value, JNI_ABORT);

  const int num_outputs = 3;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, JNI_COMMIT);
  return outputs_array;
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_quantizedMaxPool(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong min_input, jlong max_input, jlongArray ksize, jlongArray strides, jbyteArray padding) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "QuantizedMaxPool", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(input_tensor_handle, TFE_TensorHandle, input, nullptr);
  TFE_OpAddInput(op.get(), input_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(min_input_tensor_handle, TFE_TensorHandle, min_input, nullptr);
  TFE_OpAddInput(op.get(), min_input_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(max_input_tensor_handle, TFE_TensorHandle, max_input, nullptr);
  TFE_OpAddInput(op.get(), max_input_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(input_attr_T_input_tensor_h, TFE_TensorHandle, input, nullptr);
  const TF_DataType input_attr_T = TFE_TensorHandleDataType(input_attr_T_input_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", input_attr_T);

  const int ksize_n = env->GetArrayLength(ksize);
  std::unique_ptr<int64_t[]> ksize_c_value(new int64_t[ksize_n]);
  jlong* ksize_elems = env->GetLongArrayElements(ksize, nullptr);
  for (int i = 0; i < ksize_n; ++i) {
    ksize_c_value[i] = static_cast<int64_t>(ksize_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "ksize", ksize_c_value.get(), ksize_n);
  env->ReleaseLongArrayElements(ksize, ksize_elems, JNI_ABORT);

  const int strides_n = env->GetArrayLength(strides);
  std::unique_ptr<int64_t[]> strides_c_value(new int64_t[strides_n]);
  jlong* strides_elems = env->GetLongArrayElements(strides, nullptr);
  for (int i = 0; i < strides_n; ++i) {
    strides_c_value[i] = static_cast<int64_t>(strides_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "strides", strides_c_value.get(), strides_n);
  env->ReleaseLongArrayElements(strides, strides_elems, JNI_ABORT);

  jbyte *padding_c_value = env->GetByteArrayElements(padding, nullptr);
  TFE_OpSetAttrString(op.get(), "padding", reinterpret_cast<const char *>(padding_c_value));
  env->ReleaseByteArrayElements(padding, padding_c_value, JNI_ABORT);

  const int num_outputs = 3;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, JNI_COMMIT);
  return outputs_array;
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_quantizedConv2D(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong filter, jlong min_input, jlong max_input, jlong min_filter, jlong max_filter, jlongArray strides, jbyteArray padding, jint out_type) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "QuantizedConv2D", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(input_tensor_handle, TFE_TensorHandle, input, nullptr);
  TFE_OpAddInput(op.get(), input_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(filter_tensor_handle, TFE_TensorHandle, filter, nullptr);
  TFE_OpAddInput(op.get(), filter_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(min_input_tensor_handle, TFE_TensorHandle, min_input, nullptr);
  TFE_OpAddInput(op.get(), min_input_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(max_input_tensor_handle, TFE_TensorHandle, max_input, nullptr);
  TFE_OpAddInput(op.get(), max_input_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(min_filter_tensor_handle, TFE_TensorHandle, min_filter, nullptr);
  TFE_OpAddInput(op.get(), min_filter_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(max_filter_tensor_handle, TFE_TensorHandle, max_filter, nullptr);
  TFE_OpAddInput(op.get(), max_filter_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(input_attr_Tinput_input_tensor_h, TFE_TensorHandle, input, nullptr);
  const TF_DataType input_attr_Tinput = TFE_TensorHandleDataType(input_attr_Tinput_input_tensor_h);
  TFE_OpSetAttrType(op.get(), "Tinput", input_attr_Tinput);

  REQUIRE_HANDLE(filter_attr_Tfilter_filter_tensor_h, TFE_TensorHandle, filter, nullptr);
  const TF_DataType filter_attr_Tfilter = TFE_TensorHandleDataType(filter_attr_Tfilter_filter_tensor_h);
  TFE_OpSetAttrType(op.get(), "Tfilter", filter_attr_Tfilter);

  const int strides_n = env->GetArrayLength(strides);
  std::unique_ptr<int64_t[]> strides_c_value(new int64_t[strides_n]);
  jlong* strides_elems = env->GetLongArrayElements(strides, nullptr);
  for (int i = 0; i < strides_n; ++i) {
    strides_c_value[i] = static_cast<int64_t>(strides_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "strides", strides_c_value.get(), strides_n);
  env->ReleaseLongArrayElements(strides, strides_elems, JNI_ABORT);

  jbyte *padding_c_value = env->GetByteArrayElements(padding, nullptr);
  TFE_OpSetAttrString(op.get(), "padding", reinterpret_cast<const char *>(padding_c_value));
  env->ReleaseByteArrayElements(padding, padding_c_value, JNI_ABORT);

  TFE_OpSetAttrType(op.get(), "out_type", static_cast<TF_DataType>(out_type));

  const int num_outputs = 3;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, JNI_COMMIT);
  return outputs_array;
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_quantizedBatchNormWithGlobalNormalization(
    JNIEnv* env, jobject object, jlong context_handle, jlong t, jlong t_min, jlong t_max, jlong m, jlong m_min, jlong m_max, jlong v, jlong v_min, jlong v_max, jlong beta, jlong beta_min, jlong beta_max, jlong gamma, jlong gamma_min, jlong gamma_max, jint out_type, jfloat variance_epsilon, jboolean scale_after_normalization) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "QuantizedBatchNormWithGlobalNormalization", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(t_tensor_handle, TFE_TensorHandle, t, nullptr);
  TFE_OpAddInput(op.get(), t_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(t_min_tensor_handle, TFE_TensorHandle, t_min, nullptr);
  TFE_OpAddInput(op.get(), t_min_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(t_max_tensor_handle, TFE_TensorHandle, t_max, nullptr);
  TFE_OpAddInput(op.get(), t_max_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(m_tensor_handle, TFE_TensorHandle, m, nullptr);
  TFE_OpAddInput(op.get(), m_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(m_min_tensor_handle, TFE_TensorHandle, m_min, nullptr);
  TFE_OpAddInput(op.get(), m_min_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(m_max_tensor_handle, TFE_TensorHandle, m_max, nullptr);
  TFE_OpAddInput(op.get(), m_max_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(v_tensor_handle, TFE_TensorHandle, v, nullptr);
  TFE_OpAddInput(op.get(), v_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(v_min_tensor_handle, TFE_TensorHandle, v_min, nullptr);
  TFE_OpAddInput(op.get(), v_min_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(v_max_tensor_handle, TFE_TensorHandle, v_max, nullptr);
  TFE_OpAddInput(op.get(), v_max_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(beta_tensor_handle, TFE_TensorHandle, beta, nullptr);
  TFE_OpAddInput(op.get(), beta_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(beta_min_tensor_handle, TFE_TensorHandle, beta_min, nullptr);
  TFE_OpAddInput(op.get(), beta_min_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(beta_max_tensor_handle, TFE_TensorHandle, beta_max, nullptr);
  TFE_OpAddInput(op.get(), beta_max_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(gamma_tensor_handle, TFE_TensorHandle, gamma, nullptr);
  TFE_OpAddInput(op.get(), gamma_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(gamma_min_tensor_handle, TFE_TensorHandle, gamma_min, nullptr);
  TFE_OpAddInput(op.get(), gamma_min_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(gamma_max_tensor_handle, TFE_TensorHandle, gamma_max, nullptr);
  TFE_OpAddInput(op.get(), gamma_max_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(t_attr_Tinput_t_tensor_h, TFE_TensorHandle, t, nullptr);
  const TF_DataType t_attr_Tinput = TFE_TensorHandleDataType(t_attr_Tinput_t_tensor_h);
  TFE_OpSetAttrType(op.get(), "Tinput", t_attr_Tinput);

  REQUIRE_HANDLE(t_attr_Tinput_m_tensor_h, TFE_TensorHandle, m, nullptr);
  const TF_DataType m_attr_Tinput = TFE_TensorHandleDataType(t_attr_Tinput_m_tensor_h);
  if (t_attr_Tinput != m_attr_Tinput) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'm' of 'quantizedBatchNormWithGlobalNormalization' op with data type '"
          << m_attr_Tinput
          << "' must match data type '"
          << t_attr_Tinput
          << "' of argument 't'";
      throw_exception(env, jvm_illegal_argument_exception, error_msg.str().c_str());
  }

  REQUIRE_HANDLE(t_attr_Tinput_v_tensor_h, TFE_TensorHandle, v, nullptr);
  const TF_DataType v_attr_Tinput = TFE_TensorHandleDataType(t_attr_Tinput_v_tensor_h);
  if (t_attr_Tinput != v_attr_Tinput) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'v' of 'quantizedBatchNormWithGlobalNormalization' op with data type '"
          << v_attr_Tinput
          << "' must match data type '"
          << t_attr_Tinput
          << "' of argument 't'";
      throw_exception(env, jvm_illegal_argument_exception, error_msg.str().c_str());
  }

  REQUIRE_HANDLE(t_attr_Tinput_beta_tensor_h, TFE_TensorHandle, beta, nullptr);
  const TF_DataType beta_attr_Tinput = TFE_TensorHandleDataType(t_attr_Tinput_beta_tensor_h);
  if (t_attr_Tinput != beta_attr_Tinput) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'beta' of 'quantizedBatchNormWithGlobalNormalization' op with data type '"
          << beta_attr_Tinput
          << "' must match data type '"
          << t_attr_Tinput
          << "' of argument 't'";
      throw_exception(env, jvm_illegal_argument_exception, error_msg.str().c_str());
  }

  REQUIRE_HANDLE(t_attr_Tinput_gamma_tensor_h, TFE_TensorHandle, gamma, nullptr);
  const TF_DataType gamma_attr_Tinput = TFE_TensorHandleDataType(t_attr_Tinput_gamma_tensor_h);
  if (t_attr_Tinput != gamma_attr_Tinput) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'gamma' of 'quantizedBatchNormWithGlobalNormalization' op with data type '"
          << gamma_attr_Tinput
          << "' must match data type '"
          << t_attr_Tinput
          << "' of argument 't'";
      throw_exception(env, jvm_illegal_argument_exception, error_msg.str().c_str());
  }

  TFE_OpSetAttrType(op.get(), "out_type", static_cast<TF_DataType>(out_type));

  TFE_OpSetAttrFloat(op.get(), "variance_epsilon", static_cast<float>(variance_epsilon));

  TFE_OpSetAttrBool(op.get(), "scale_after_normalization", static_cast<unsigned char>(scale_after_normalization));

  const int num_outputs = 3;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, JNI_COMMIT);
  return outputs_array;
}
