/* DO NOT EDIT THIS FILE - it is machine generated */

/* Copyright 2017, Emmanouil Antonios Platanios. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

#include "tensor_basic_ops.h"

#include <algorithm>
#include <cstring>
#include <memory>
#include <sstream>

#include "include/c_api.h"
#include "include/c_eager_api.h"
#include "include/exception_jni.h"
#include "include/utilities.h"

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_zerosLike(
    JNIEnv* env, jobject object, jlong context_handle, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "ZerosLike", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_tensor_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_attr_T_x_tensor_h, TFE_TensorHandle, x, 0);
  const TF_DataType x_attr_T = TFE_TensorHandleDataType(x_attr_T_x_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", x_attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_onesLike(
    JNIEnv* env, jobject object, jlong context_handle, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "OnesLike", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_tensor_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_attr_T_x_tensor_h, TFE_TensorHandle, x, 0);
  const TF_DataType x_attr_T = TFE_TensorHandleDataType(x_attr_T_x_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", x_attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_fill(
    JNIEnv* env, jobject object, jlong context_handle, jlong dims, jlong value) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Fill", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(dims_tensor_handle, TFE_TensorHandle, dims, 0);
  TFE_OpAddInput(op.get(), dims_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(value_tensor_handle, TFE_TensorHandle, value, 0);
  TFE_OpAddInput(op.get(), value_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(value_attr_T_value_tensor_h, TFE_TensorHandle, value, 0);
  const TF_DataType value_attr_T = TFE_TensorHandleDataType(value_attr_T_value_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", value_attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_rank(
    JNIEnv* env, jobject object, jlong context_handle, jlong input) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Rank", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_tensor_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_attr_T_input_tensor_h, TFE_TensorHandle, input, 0);
  const TF_DataType input_attr_T = TFE_TensorHandleDataType(input_attr_T_input_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", input_attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_size(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jint out_type) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Size", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_tensor_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_attr_T_input_tensor_h, TFE_TensorHandle, input, 0);
  const TF_DataType input_attr_T = TFE_TensorHandleDataType(input_attr_T_input_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", input_attr_T);

  TFE_OpSetAttrType(op.get(), "out_type", static_cast<TF_DataType>(out_type));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_shape(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jint out_type) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Shape", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_tensor_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_attr_T_input_tensor_h, TFE_TensorHandle, input, 0);
  const TF_DataType input_attr_T = TFE_TensorHandleDataType(input_attr_T_input_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", input_attr_T);

  TFE_OpSetAttrType(op.get(), "out_type", static_cast<TF_DataType>(out_type));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_expandDims(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong dim) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "ExpandDims", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_tensor_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(dim_tensor_handle, TFE_TensorHandle, dim, 0);
  TFE_OpAddInput(op.get(), dim_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_attr_T_input_tensor_h, TFE_TensorHandle, input, 0);
  const TF_DataType input_attr_T = TFE_TensorHandleDataType(input_attr_T_input_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", input_attr_T);

  REQUIRE_HANDLE(dim_attr_Tdim_dim_tensor_h, TFE_TensorHandle, dim, 0);
  const TF_DataType dim_attr_Tdim = TFE_TensorHandleDataType(dim_attr_Tdim_dim_tensor_h);
  TFE_OpSetAttrType(op.get(), "Tdim", dim_attr_Tdim);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_squeeze(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlongArray squeeze_dims) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Squeeze", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_tensor_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_attr_T_input_tensor_h, TFE_TensorHandle, input, 0);
  const TF_DataType input_attr_T = TFE_TensorHandleDataType(input_attr_T_input_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", input_attr_T);

  const int squeeze_dims_n = env->GetArrayLength(squeeze_dims);
  std::unique_ptr<int64_t[]> squeeze_dims_c_value(new int64_t[squeeze_dims_n]);
  jlong* squeeze_dims_elems = env->GetLongArrayElements(squeeze_dims, nullptr);
  for (int i = 0; i < squeeze_dims_n; ++i) {
    squeeze_dims_c_value[i] = static_cast<int64_t>(squeeze_dims_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "squeeze_dims", squeeze_dims_c_value.get(), squeeze_dims_n);
  env->ReleaseLongArrayElements(squeeze_dims, squeeze_dims_elems, JNI_ABORT);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_pack(
    JNIEnv* env, jobject object, jlong context_handle, jlongArray values, jlong axis) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Pack", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  const int values_num_tensors = env->GetArrayLength(values);
  jlong *values_elems = env->GetLongArrayElements(values, nullptr);
  for (int i = 0; i < values_num_tensors; ++i) {
    REQUIRE_HANDLE(tensor_handle, TFE_TensorHandle, values_elems[i], 0);
    TFE_OpAddInput(op.get(), tensor_handle, status.get());
    CHECK_STATUS(env, status.get(), 0);
  }
  env->ReleaseLongArrayElements(values, values_elems, JNI_ABORT);

  const int values_attr_N = env->GetArrayLength(values);
  TFE_OpSetAttrInt(op.get(), "N", static_cast<int64_t>(values_attr_N));

  const int values_attr_T_num_tensors = env->GetArrayLength(values);
  jlong *values_attr_T_elems = env->GetLongArrayElements(values, nullptr);

  REQUIRE_HANDLE(values_attr_T_elems_head, TFE_TensorHandle, values_attr_T_elems[0], 0);
  const TF_DataType values_attr_T = TFE_TensorHandleDataType(values_attr_T_elems_head);
  TFE_OpSetAttrType(op.get(), "T", values_attr_T);

  for (int i = 0; i < values_attr_T_num_tensors; ++i) {
    REQUIRE_HANDLE(tensor, TFE_TensorHandle, values_attr_T_elems[i], 0);
    const TF_DataType data_type = TFE_TensorHandleDataType(tensor);
    if (values_attr_T != data_type) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'values' of 'pack' op with data type '"
          << data_type
          << "' must match data type '"
          << values_attr_T
          << "' of argument 'values'";
      throw_exception(env, jvm_illegal_argument_exception, error_msg.str().c_str());
    }
  }
  env->ReleaseLongArrayElements(values, values_attr_T_elems, JNI_ABORT);

  TFE_OpSetAttrInt(op.get(), "axis", static_cast<int64_t>(axis));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_parallelConcat(
    JNIEnv* env, jobject object, jlong context_handle, jlongArray values, jlongArray shape) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "ParallelConcat", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  const int values_num_tensors = env->GetArrayLength(values);
  jlong *values_elems = env->GetLongArrayElements(values, nullptr);
  for (int i = 0; i < values_num_tensors; ++i) {
    REQUIRE_HANDLE(tensor_handle, TFE_TensorHandle, values_elems[i], 0);
    TFE_OpAddInput(op.get(), tensor_handle, status.get());
    CHECK_STATUS(env, status.get(), 0);
  }
  env->ReleaseLongArrayElements(values, values_elems, JNI_ABORT);

  const int values_attr_N = env->GetArrayLength(values);
  TFE_OpSetAttrInt(op.get(), "N", static_cast<int64_t>(values_attr_N));

  const int values_attr_T_num_tensors = env->GetArrayLength(values);
  jlong *values_attr_T_elems = env->GetLongArrayElements(values, nullptr);

  REQUIRE_HANDLE(values_attr_T_elems_head, TFE_TensorHandle, values_attr_T_elems[0], 0);
  const TF_DataType values_attr_T = TFE_TensorHandleDataType(values_attr_T_elems_head);
  TFE_OpSetAttrType(op.get(), "T", values_attr_T);

  for (int i = 0; i < values_attr_T_num_tensors; ++i) {
    REQUIRE_HANDLE(tensor, TFE_TensorHandle, values_attr_T_elems[i], 0);
    const TF_DataType data_type = TFE_TensorHandleDataType(tensor);
    if (values_attr_T != data_type) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'values' of 'parallelConcat' op with data type '"
          << data_type
          << "' must match data type '"
          << values_attr_T
          << "' of argument 'values'";
      throw_exception(env, jvm_illegal_argument_exception, error_msg.str().c_str());
    }
  }
  env->ReleaseLongArrayElements(values, values_attr_T_elems, JNI_ABORT);

  std::unique_ptr<int64_t[]> shape_c_value;
  int shape_num_dims = -1;
  if (shape != nullptr) {
    shape_num_dims = env->GetArrayLength(shape);
    shape_c_value.reset(new int64_t[shape_num_dims]);
    jlong *shape_elems = env->GetLongArrayElements(shape, nullptr);
    for (int i = 0; i < shape_num_dims; ++i) {
      shape_c_value[i] = static_cast<int64_t>(shape_elems[i]);
    }
    env->ReleaseLongArrayElements(shape, shape_elems, JNI_ABORT);
  }
  TFE_OpSetAttrShape(
      op.get(), "shape", shape_c_value.get(), static_cast<int>(shape_num_dims),
      status.get());
  CHECK_STATUS(env, status.get(), 0);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_unpack(
    JNIEnv* env, jobject object, jlong context_handle, jlong value, jlong num, jlong axis) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Unpack", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(value_tensor_handle, TFE_TensorHandle, value, nullptr);
  TFE_OpAddInput(op.get(), value_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(value_attr_T_value_tensor_h, TFE_TensorHandle, value, nullptr);
  const TF_DataType value_attr_T = TFE_TensorHandleDataType(value_attr_T_value_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", value_attr_T);

  TFE_OpSetAttrInt(op.get(), "num", static_cast<int64_t>(num));

  TFE_OpSetAttrInt(op.get(), "axis", static_cast<int64_t>(axis));

  const int num_outputs = num;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, JNI_COMMIT);
  return outputs_array;
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_concatV2(
    JNIEnv* env, jobject object, jlong context_handle, jlongArray values, jlong axis) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "ConcatV2", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  const int values_num_tensors = env->GetArrayLength(values);
  jlong *values_elems = env->GetLongArrayElements(values, nullptr);
  for (int i = 0; i < values_num_tensors; ++i) {
    REQUIRE_HANDLE(tensor_handle, TFE_TensorHandle, values_elems[i], 0);
    TFE_OpAddInput(op.get(), tensor_handle, status.get());
    CHECK_STATUS(env, status.get(), 0);
  }
  env->ReleaseLongArrayElements(values, values_elems, JNI_ABORT);

  REQUIRE_HANDLE(axis_tensor_handle, TFE_TensorHandle, axis, 0);
  TFE_OpAddInput(op.get(), axis_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  const int values_attr_N = env->GetArrayLength(values);
  TFE_OpSetAttrInt(op.get(), "N", static_cast<int64_t>(values_attr_N));

  const int values_attr_T_num_tensors = env->GetArrayLength(values);
  jlong *values_attr_T_elems = env->GetLongArrayElements(values, nullptr);

  REQUIRE_HANDLE(values_attr_T_elems_head, TFE_TensorHandle, values_attr_T_elems[0], 0);
  const TF_DataType values_attr_T = TFE_TensorHandleDataType(values_attr_T_elems_head);
  TFE_OpSetAttrType(op.get(), "T", values_attr_T);

  for (int i = 0; i < values_attr_T_num_tensors; ++i) {
    REQUIRE_HANDLE(tensor, TFE_TensorHandle, values_attr_T_elems[i], 0);
    const TF_DataType data_type = TFE_TensorHandleDataType(tensor);
    if (values_attr_T != data_type) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'values' of 'concatV2' op with data type '"
          << data_type
          << "' must match data type '"
          << values_attr_T
          << "' of argument 'values'";
      throw_exception(env, jvm_illegal_argument_exception, error_msg.str().c_str());
    }
  }
  env->ReleaseLongArrayElements(values, values_attr_T_elems, JNI_ABORT);

  REQUIRE_HANDLE(axis_attr_Tidx_axis_tensor_h, TFE_TensorHandle, axis, 0);
  const TF_DataType axis_attr_Tidx = TFE_TensorHandleDataType(axis_attr_Tidx_axis_tensor_h);
  TFE_OpSetAttrType(op.get(), "Tidx", axis_attr_Tidx);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_concatOffset(
    JNIEnv* env, jobject object, jlong context_handle, jlong concat_dim, jlongArray shape) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "ConcatOffset", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(concat_dim_tensor_handle, TFE_TensorHandle, concat_dim, nullptr);
  TFE_OpAddInput(op.get(), concat_dim_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  const int shape_num_tensors = env->GetArrayLength(shape);
  jlong *shape_elems = env->GetLongArrayElements(shape, nullptr);
  for (int i = 0; i < shape_num_tensors; ++i) {
    REQUIRE_HANDLE(tensor_handle, TFE_TensorHandle, shape_elems[i], 0);
    TFE_OpAddInput(op.get(), tensor_handle, status.get());
    CHECK_STATUS(env, status.get(), nullptr);
  }
  env->ReleaseLongArrayElements(shape, shape_elems, JNI_ABORT);

  const int shape_attr_N = env->GetArrayLength(shape);
  TFE_OpSetAttrInt(op.get(), "N", static_cast<int64_t>(shape_attr_N));

  const int num_outputs = shape_attr_N;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, JNI_COMMIT);
  return outputs_array;
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_split(
    JNIEnv* env, jobject object, jlong context_handle, jlong split_dim, jlong value, jlong num_split) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Split", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(split_dim_tensor_handle, TFE_TensorHandle, split_dim, nullptr);
  TFE_OpAddInput(op.get(), split_dim_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(value_tensor_handle, TFE_TensorHandle, value, nullptr);
  TFE_OpAddInput(op.get(), value_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(value_attr_T_value_tensor_h, TFE_TensorHandle, value, nullptr);
  const TF_DataType value_attr_T = TFE_TensorHandleDataType(value_attr_T_value_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", value_attr_T);

  TFE_OpSetAttrInt(op.get(), "num_split", static_cast<int64_t>(num_split));

  const int num_outputs = num_split;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, JNI_COMMIT);
  return outputs_array;
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_splitV(
    JNIEnv* env, jobject object, jlong context_handle, jlong value, jlong size_splits, jlong split_dim, jlong num_split) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "SplitV", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(value_tensor_handle, TFE_TensorHandle, value, nullptr);
  TFE_OpAddInput(op.get(), value_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(size_splits_tensor_handle, TFE_TensorHandle, size_splits, nullptr);
  TFE_OpAddInput(op.get(), size_splits_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(split_dim_tensor_handle, TFE_TensorHandle, split_dim, nullptr);
  TFE_OpAddInput(op.get(), split_dim_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(value_attr_T_value_tensor_h, TFE_TensorHandle, value, nullptr);
  const TF_DataType value_attr_T = TFE_TensorHandleDataType(value_attr_T_value_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", value_attr_T);

  REQUIRE_HANDLE(size_splits_attr_Tlen_size_splits_tensor_h, TFE_TensorHandle, size_splits, nullptr);
  const TF_DataType size_splits_attr_Tlen = TFE_TensorHandleDataType(size_splits_attr_Tlen_size_splits_tensor_h);
  TFE_OpSetAttrType(op.get(), "Tlen", size_splits_attr_Tlen);

  TFE_OpSetAttrInt(op.get(), "num_split", static_cast<int64_t>(num_split));

  const int num_outputs = num_split;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, JNI_COMMIT);
  return outputs_array;
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_tile(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong multiples) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Tile", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_tensor_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(multiples_tensor_handle, TFE_TensorHandle, multiples, 0);
  TFE_OpAddInput(op.get(), multiples_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_attr_T_input_tensor_h, TFE_TensorHandle, input, 0);
  const TF_DataType input_attr_T = TFE_TensorHandleDataType(input_attr_T_input_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", input_attr_T);

  REQUIRE_HANDLE(multiples_attr_Tmultiples_multiples_tensor_h, TFE_TensorHandle, multiples, 0);
  const TF_DataType multiples_attr_Tmultiples = TFE_TensorHandleDataType(multiples_attr_Tmultiples_multiples_tensor_h);
  TFE_OpSetAttrType(op.get(), "Tmultiples", multiples_attr_Tmultiples);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_pad(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong paddings) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Pad", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_tensor_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(paddings_tensor_handle, TFE_TensorHandle, paddings, 0);
  TFE_OpAddInput(op.get(), paddings_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_attr_T_input_tensor_h, TFE_TensorHandle, input, 0);
  const TF_DataType input_attr_T = TFE_TensorHandleDataType(input_attr_T_input_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", input_attr_T);

  REQUIRE_HANDLE(paddings_attr_Tpaddings_paddings_tensor_h, TFE_TensorHandle, paddings, 0);
  const TF_DataType paddings_attr_Tpaddings = TFE_TensorHandleDataType(paddings_attr_Tpaddings_paddings_tensor_h);
  TFE_OpSetAttrType(op.get(), "Tpaddings", paddings_attr_Tpaddings);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_mirrorPad(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong paddings, jbyteArray mode) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "MirrorPad", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_tensor_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(paddings_tensor_handle, TFE_TensorHandle, paddings, 0);
  TFE_OpAddInput(op.get(), paddings_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_attr_T_input_tensor_h, TFE_TensorHandle, input, 0);
  const TF_DataType input_attr_T = TFE_TensorHandleDataType(input_attr_T_input_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", input_attr_T);

  REQUIRE_HANDLE(paddings_attr_Tpaddings_paddings_tensor_h, TFE_TensorHandle, paddings, 0);
  const TF_DataType paddings_attr_Tpaddings = TFE_TensorHandleDataType(paddings_attr_Tpaddings_paddings_tensor_h);
  TFE_OpSetAttrType(op.get(), "Tpaddings", paddings_attr_Tpaddings);

  jbyte *mode_c_value = env->GetByteArrayElements(mode, nullptr);
  TFE_OpSetAttrString(op.get(), "mode", reinterpret_cast<const char *>(mode_c_value));
  env->ReleaseByteArrayElements(mode, mode_c_value, JNI_ABORT);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_reshape(
    JNIEnv* env, jobject object, jlong context_handle, jlong tensor, jlong shape) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Reshape", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(tensor_tensor_handle, TFE_TensorHandle, tensor, 0);
  TFE_OpAddInput(op.get(), tensor_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(shape_tensor_handle, TFE_TensorHandle, shape, 0);
  TFE_OpAddInput(op.get(), shape_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(tensor_attr_T_tensor_tensor_h, TFE_TensorHandle, tensor, 0);
  const TF_DataType tensor_attr_T = TFE_TensorHandleDataType(tensor_attr_T_tensor_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", tensor_attr_T);

  REQUIRE_HANDLE(shape_attr_Tshape_shape_tensor_h, TFE_TensorHandle, shape, 0);
  const TF_DataType shape_attr_Tshape = TFE_TensorHandleDataType(shape_attr_Tshape_shape_tensor_h);
  TFE_OpSetAttrType(op.get(), "Tshape", shape_attr_Tshape);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_transpose(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jlong perm) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Transpose", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_tensor_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(perm_tensor_handle, TFE_TensorHandle, perm, 0);
  TFE_OpAddInput(op.get(), perm_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_attr_T_x_tensor_h, TFE_TensorHandle, x, 0);
  const TF_DataType x_attr_T = TFE_TensorHandleDataType(x_attr_T_x_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", x_attr_T);

  REQUIRE_HANDLE(perm_attr_Tperm_perm_tensor_h, TFE_TensorHandle, perm, 0);
  const TF_DataType perm_attr_Tperm = TFE_TensorHandleDataType(perm_attr_Tperm_perm_tensor_h);
  TFE_OpSetAttrType(op.get(), "Tperm", perm_attr_Tperm);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_invertPermutation(
    JNIEnv* env, jobject object, jlong context_handle, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "InvertPermutation", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_tensor_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_attr_T_x_tensor_h, TFE_TensorHandle, x, 0);
  const TF_DataType x_attr_T = TFE_TensorHandleDataType(x_attr_T_x_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", x_attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_reverseV2(
    JNIEnv* env, jobject object, jlong context_handle, jlong tensor, jlong axis) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "ReverseV2", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(tensor_tensor_handle, TFE_TensorHandle, tensor, 0);
  TFE_OpAddInput(op.get(), tensor_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(axis_tensor_handle, TFE_TensorHandle, axis, 0);
  TFE_OpAddInput(op.get(), axis_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(axis_attr_Tidx_axis_tensor_h, TFE_TensorHandle, axis, 0);
  const TF_DataType axis_attr_Tidx = TFE_TensorHandleDataType(axis_attr_Tidx_axis_tensor_h);
  TFE_OpSetAttrType(op.get(), "Tidx", axis_attr_Tidx);

  REQUIRE_HANDLE(tensor_attr_T_tensor_tensor_h, TFE_TensorHandle, tensor, 0);
  const TF_DataType tensor_attr_T = TFE_TensorHandleDataType(tensor_attr_T_tensor_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", tensor_attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_reverseSequence(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong seq_lengths, jlong seq_dim, jlong batch_dim) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "ReverseSequence", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_tensor_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(seq_lengths_tensor_handle, TFE_TensorHandle, seq_lengths, 0);
  TFE_OpAddInput(op.get(), seq_lengths_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_attr_T_input_tensor_h, TFE_TensorHandle, input, 0);
  const TF_DataType input_attr_T = TFE_TensorHandleDataType(input_attr_T_input_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", input_attr_T);

  REQUIRE_HANDLE(seq_lengths_attr_Tlen_seq_lengths_tensor_h, TFE_TensorHandle, seq_lengths, 0);
  const TF_DataType seq_lengths_attr_Tlen = TFE_TensorHandleDataType(seq_lengths_attr_Tlen_seq_lengths_tensor_h);
  TFE_OpSetAttrType(op.get(), "Tlen", seq_lengths_attr_Tlen);

  TFE_OpSetAttrInt(op.get(), "seq_dim", static_cast<int64_t>(seq_dim));

  TFE_OpSetAttrInt(op.get(), "batch_dim", static_cast<int64_t>(batch_dim));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_spaceToBatchND(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong block_shape, jlong paddings) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "SpaceToBatchND", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_tensor_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(block_shape_tensor_handle, TFE_TensorHandle, block_shape, 0);
  TFE_OpAddInput(op.get(), block_shape_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(paddings_tensor_handle, TFE_TensorHandle, paddings, 0);
  TFE_OpAddInput(op.get(), paddings_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_attr_T_input_tensor_h, TFE_TensorHandle, input, 0);
  const TF_DataType input_attr_T = TFE_TensorHandleDataType(input_attr_T_input_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", input_attr_T);

  REQUIRE_HANDLE(block_shape_attr_Tblock_shape_block_shape_tensor_h, TFE_TensorHandle, block_shape, 0);
  const TF_DataType block_shape_attr_Tblock_shape = TFE_TensorHandleDataType(block_shape_attr_Tblock_shape_block_shape_tensor_h);
  TFE_OpSetAttrType(op.get(), "Tblock_shape", block_shape_attr_Tblock_shape);

  REQUIRE_HANDLE(paddings_attr_Tpaddings_paddings_tensor_h, TFE_TensorHandle, paddings, 0);
  const TF_DataType paddings_attr_Tpaddings = TFE_TensorHandleDataType(paddings_attr_Tpaddings_paddings_tensor_h);
  TFE_OpSetAttrType(op.get(), "Tpaddings", paddings_attr_Tpaddings);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_batchToSpaceND(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong block_shape, jlong crops) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "BatchToSpaceND", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_tensor_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(block_shape_tensor_handle, TFE_TensorHandle, block_shape, 0);
  TFE_OpAddInput(op.get(), block_shape_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(crops_tensor_handle, TFE_TensorHandle, crops, 0);
  TFE_OpAddInput(op.get(), crops_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_attr_T_input_tensor_h, TFE_TensorHandle, input, 0);
  const TF_DataType input_attr_T = TFE_TensorHandleDataType(input_attr_T_input_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", input_attr_T);

  REQUIRE_HANDLE(block_shape_attr_Tblock_shape_block_shape_tensor_h, TFE_TensorHandle, block_shape, 0);
  const TF_DataType block_shape_attr_Tblock_shape = TFE_TensorHandleDataType(block_shape_attr_Tblock_shape_block_shape_tensor_h);
  TFE_OpSetAttrType(op.get(), "Tblock_shape", block_shape_attr_Tblock_shape);

  REQUIRE_HANDLE(crops_attr_Tcrops_crops_tensor_h, TFE_TensorHandle, crops, 0);
  const TF_DataType crops_attr_Tcrops = TFE_TensorHandleDataType(crops_attr_Tcrops_crops_tensor_h);
  TFE_OpSetAttrType(op.get(), "Tcrops", crops_attr_Tcrops);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_spaceToDepth(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong block_size) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "SpaceToDepth", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_tensor_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_attr_T_input_tensor_h, TFE_TensorHandle, input, 0);
  const TF_DataType input_attr_T = TFE_TensorHandleDataType(input_attr_T_input_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", input_attr_T);

  TFE_OpSetAttrInt(op.get(), "block_size", static_cast<int64_t>(block_size));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_depthToSpace(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong block_size) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "DepthToSpace", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_tensor_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_attr_T_input_tensor_h, TFE_TensorHandle, input, 0);
  const TF_DataType input_attr_T = TFE_TensorHandleDataType(input_attr_T_input_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", input_attr_T);

  TFE_OpSetAttrInt(op.get(), "block_size", static_cast<int64_t>(block_size));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_where(
    JNIEnv* env, jobject object, jlong context_handle, jlong input) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Where", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_tensor_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_unique(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jint out_idx) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Unique", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(x_tensor_handle, TFE_TensorHandle, x, nullptr);
  TFE_OpAddInput(op.get(), x_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(x_attr_T_x_tensor_h, TFE_TensorHandle, x, nullptr);
  const TF_DataType x_attr_T = TFE_TensorHandleDataType(x_attr_T_x_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", x_attr_T);

  TFE_OpSetAttrType(op.get(), "out_idx", static_cast<TF_DataType>(out_idx));

  const int num_outputs = 2;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, JNI_COMMIT);
  return outputs_array;
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_uniqueWithCounts(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jint out_idx) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "UniqueWithCounts", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(x_tensor_handle, TFE_TensorHandle, x, nullptr);
  TFE_OpAddInput(op.get(), x_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(x_attr_T_x_tensor_h, TFE_TensorHandle, x, nullptr);
  const TF_DataType x_attr_T = TFE_TensorHandleDataType(x_attr_T_x_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", x_attr_T);

  TFE_OpSetAttrType(op.get(), "out_idx", static_cast<TF_DataType>(out_idx));

  const int num_outputs = 3;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, JNI_COMMIT);
  return outputs_array;
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_listDiff(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jlong y, jint out_idx) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "ListDiff", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(x_tensor_handle, TFE_TensorHandle, x, nullptr);
  TFE_OpAddInput(op.get(), x_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(y_tensor_handle, TFE_TensorHandle, y, nullptr);
  TFE_OpAddInput(op.get(), y_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(x_attr_T_x_tensor_h, TFE_TensorHandle, x, nullptr);
  const TF_DataType x_attr_T = TFE_TensorHandleDataType(x_attr_T_x_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", x_attr_T);

  REQUIRE_HANDLE(x_attr_T_y_tensor_h, TFE_TensorHandle, y, nullptr);
  const TF_DataType y_attr_T = TFE_TensorHandleDataType(x_attr_T_y_tensor_h);
  if (x_attr_T != y_attr_T) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'y' of 'listDiff' op with data type '"
          << y_attr_T
          << "' must match data type '"
          << x_attr_T
          << "' of argument 'x'";
      throw_exception(env, jvm_illegal_argument_exception, error_msg.str().c_str());
  }

  TFE_OpSetAttrType(op.get(), "out_idx", static_cast<TF_DataType>(out_idx));

  const int num_outputs = 2;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, JNI_COMMIT);
  return outputs_array;
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_gatherV2(
    JNIEnv* env, jobject object, jlong context_handle, jlong params, jlong indices, jlong axis) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "GatherV2", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(params_tensor_handle, TFE_TensorHandle, params, 0);
  TFE_OpAddInput(op.get(), params_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(indices_tensor_handle, TFE_TensorHandle, indices, 0);
  TFE_OpAddInput(op.get(), indices_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(axis_tensor_handle, TFE_TensorHandle, axis, 0);
  TFE_OpAddInput(op.get(), axis_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(params_attr_Tparams_params_tensor_h, TFE_TensorHandle, params, 0);
  const TF_DataType params_attr_Tparams = TFE_TensorHandleDataType(params_attr_Tparams_params_tensor_h);
  TFE_OpSetAttrType(op.get(), "Tparams", params_attr_Tparams);

  REQUIRE_HANDLE(indices_attr_Tindices_indices_tensor_h, TFE_TensorHandle, indices, 0);
  const TF_DataType indices_attr_Tindices = TFE_TensorHandleDataType(indices_attr_Tindices_indices_tensor_h);
  TFE_OpSetAttrType(op.get(), "Tindices", indices_attr_Tindices);

  REQUIRE_HANDLE(axis_attr_Taxis_axis_tensor_h, TFE_TensorHandle, axis, 0);
  const TF_DataType axis_attr_Taxis = TFE_TensorHandleDataType(axis_attr_Taxis_axis_tensor_h);
  TFE_OpSetAttrType(op.get(), "Taxis", axis_attr_Taxis);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_gatherNd(
    JNIEnv* env, jobject object, jlong context_handle, jlong params, jlong indices) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "GatherNd", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(params_tensor_handle, TFE_TensorHandle, params, 0);
  TFE_OpAddInput(op.get(), params_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(indices_tensor_handle, TFE_TensorHandle, indices, 0);
  TFE_OpAddInput(op.get(), indices_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(params_attr_Tparams_params_tensor_h, TFE_TensorHandle, params, 0);
  const TF_DataType params_attr_Tparams = TFE_TensorHandleDataType(params_attr_Tparams_params_tensor_h);
  TFE_OpSetAttrType(op.get(), "Tparams", params_attr_Tparams);

  REQUIRE_HANDLE(indices_attr_Tindices_indices_tensor_h, TFE_TensorHandle, indices, 0);
  const TF_DataType indices_attr_Tindices = TFE_TensorHandleDataType(indices_attr_Tindices_indices_tensor_h);
  TFE_OpSetAttrType(op.get(), "Tindices", indices_attr_Tindices);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_scatterNd(
    JNIEnv* env, jobject object, jlong context_handle, jlong indices, jlong updates, jlong shape) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "ScatterNd", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(indices_tensor_handle, TFE_TensorHandle, indices, 0);
  TFE_OpAddInput(op.get(), indices_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(updates_tensor_handle, TFE_TensorHandle, updates, 0);
  TFE_OpAddInput(op.get(), updates_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(shape_tensor_handle, TFE_TensorHandle, shape, 0);
  TFE_OpAddInput(op.get(), shape_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(updates_attr_T_updates_tensor_h, TFE_TensorHandle, updates, 0);
  const TF_DataType updates_attr_T = TFE_TensorHandleDataType(updates_attr_T_updates_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", updates_attr_T);

  REQUIRE_HANDLE(indices_attr_Tindices_indices_tensor_h, TFE_TensorHandle, indices, 0);
  const TF_DataType indices_attr_Tindices = TFE_TensorHandleDataType(indices_attr_Tindices_indices_tensor_h);
  TFE_OpSetAttrType(op.get(), "Tindices", indices_attr_Tindices);

  REQUIRE_HANDLE(indices_attr_Tindices_shape_tensor_h, TFE_TensorHandle, shape, 0);
  const TF_DataType shape_attr_Tindices = TFE_TensorHandleDataType(indices_attr_Tindices_shape_tensor_h);
  if (indices_attr_Tindices != shape_attr_Tindices) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'shape' of 'scatterNd' op with data type '"
          << shape_attr_Tindices
          << "' must match data type '"
          << indices_attr_Tindices
          << "' of argument 'indices'";
      throw_exception(env, jvm_illegal_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_slice(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong begin, jlong size) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Slice", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_tensor_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(begin_tensor_handle, TFE_TensorHandle, begin, 0);
  TFE_OpAddInput(op.get(), begin_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(size_tensor_handle, TFE_TensorHandle, size, 0);
  TFE_OpAddInput(op.get(), size_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_attr_T_input_tensor_h, TFE_TensorHandle, input, 0);
  const TF_DataType input_attr_T = TFE_TensorHandleDataType(input_attr_T_input_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", input_attr_T);

  REQUIRE_HANDLE(begin_attr_Index_begin_tensor_h, TFE_TensorHandle, begin, 0);
  const TF_DataType begin_attr_Index = TFE_TensorHandleDataType(begin_attr_Index_begin_tensor_h);
  TFE_OpSetAttrType(op.get(), "Index", begin_attr_Index);

  REQUIRE_HANDLE(begin_attr_Index_size_tensor_h, TFE_TensorHandle, size, 0);
  const TF_DataType size_attr_Index = TFE_TensorHandleDataType(begin_attr_Index_size_tensor_h);
  if (begin_attr_Index != size_attr_Index) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'size' of 'slice' op with data type '"
          << size_attr_Index
          << "' must match data type '"
          << begin_attr_Index
          << "' of argument 'begin'";
      throw_exception(env, jvm_illegal_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_stridedSlice(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong begin, jlong end, jlong strides, jlong begin_mask, jlong end_mask, jlong ellipsis_mask, jlong new_axis_mask, jlong shrink_axis_mask) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "StridedSlice", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_tensor_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(begin_tensor_handle, TFE_TensorHandle, begin, 0);
  TFE_OpAddInput(op.get(), begin_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(end_tensor_handle, TFE_TensorHandle, end, 0);
  TFE_OpAddInput(op.get(), end_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(strides_tensor_handle, TFE_TensorHandle, strides, 0);
  TFE_OpAddInput(op.get(), strides_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_attr_T_input_tensor_h, TFE_TensorHandle, input, 0);
  const TF_DataType input_attr_T = TFE_TensorHandleDataType(input_attr_T_input_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", input_attr_T);

  REQUIRE_HANDLE(begin_attr_Index_begin_tensor_h, TFE_TensorHandle, begin, 0);
  const TF_DataType begin_attr_Index = TFE_TensorHandleDataType(begin_attr_Index_begin_tensor_h);
  TFE_OpSetAttrType(op.get(), "Index", begin_attr_Index);

  REQUIRE_HANDLE(begin_attr_Index_end_tensor_h, TFE_TensorHandle, end, 0);
  const TF_DataType end_attr_Index = TFE_TensorHandleDataType(begin_attr_Index_end_tensor_h);
  if (begin_attr_Index != end_attr_Index) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'end' of 'stridedSlice' op with data type '"
          << end_attr_Index
          << "' must match data type '"
          << begin_attr_Index
          << "' of argument 'begin'";
      throw_exception(env, jvm_illegal_argument_exception, error_msg.str().c_str());
  }

  REQUIRE_HANDLE(begin_attr_Index_strides_tensor_h, TFE_TensorHandle, strides, 0);
  const TF_DataType strides_attr_Index = TFE_TensorHandleDataType(begin_attr_Index_strides_tensor_h);
  if (begin_attr_Index != strides_attr_Index) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'strides' of 'stridedSlice' op with data type '"
          << strides_attr_Index
          << "' must match data type '"
          << begin_attr_Index
          << "' of argument 'begin'";
      throw_exception(env, jvm_illegal_argument_exception, error_msg.str().c_str());
  }

  TFE_OpSetAttrInt(op.get(), "begin_mask", static_cast<int64_t>(begin_mask));

  TFE_OpSetAttrInt(op.get(), "end_mask", static_cast<int64_t>(end_mask));

  TFE_OpSetAttrInt(op.get(), "ellipsis_mask", static_cast<int64_t>(ellipsis_mask));

  TFE_OpSetAttrInt(op.get(), "new_axis_mask", static_cast<int64_t>(new_axis_mask));

  TFE_OpSetAttrInt(op.get(), "shrink_axis_mask", static_cast<int64_t>(shrink_axis_mask));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_checkNumerics(
    JNIEnv* env, jobject object, jlong context_handle, jlong tensor, jbyteArray message) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "CheckNumerics", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(tensor_tensor_handle, TFE_TensorHandle, tensor, 0);
  TFE_OpAddInput(op.get(), tensor_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(tensor_attr_T_tensor_tensor_h, TFE_TensorHandle, tensor, 0);
  const TF_DataType tensor_attr_T = TFE_TensorHandleDataType(tensor_attr_T_tensor_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", tensor_attr_T);

  jbyte *message_c_value = env->GetByteArrayElements(message, nullptr);
  TFE_OpSetAttrString(op.get(), "message", reinterpret_cast<const char *>(message_c_value));
  env->ReleaseByteArrayElements(message, message_c_value, JNI_ABORT);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_editDistance(
    JNIEnv* env, jobject object, jlong context_handle, jlong hypothesis_indices, jlong hypothesis_values, jlong hypothesis_shape, jlong truth_indices, jlong truth_values, jlong truth_shape, jboolean normalize) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "EditDistance", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(hypothesis_indices_tensor_handle, TFE_TensorHandle, hypothesis_indices, 0);
  TFE_OpAddInput(op.get(), hypothesis_indices_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(hypothesis_values_tensor_handle, TFE_TensorHandle, hypothesis_values, 0);
  TFE_OpAddInput(op.get(), hypothesis_values_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(hypothesis_shape_tensor_handle, TFE_TensorHandle, hypothesis_shape, 0);
  TFE_OpAddInput(op.get(), hypothesis_shape_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(truth_indices_tensor_handle, TFE_TensorHandle, truth_indices, 0);
  TFE_OpAddInput(op.get(), truth_indices_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(truth_values_tensor_handle, TFE_TensorHandle, truth_values, 0);
  TFE_OpAddInput(op.get(), truth_values_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(truth_shape_tensor_handle, TFE_TensorHandle, truth_shape, 0);
  TFE_OpAddInput(op.get(), truth_shape_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(hypothesis_values_attr_T_hypothesis_values_tensor_h, TFE_TensorHandle, hypothesis_values, 0);
  const TF_DataType hypothesis_values_attr_T = TFE_TensorHandleDataType(hypothesis_values_attr_T_hypothesis_values_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", hypothesis_values_attr_T);

  REQUIRE_HANDLE(hypothesis_values_attr_T_truth_values_tensor_h, TFE_TensorHandle, truth_values, 0);
  const TF_DataType truth_values_attr_T = TFE_TensorHandleDataType(hypothesis_values_attr_T_truth_values_tensor_h);
  if (hypothesis_values_attr_T != truth_values_attr_T) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'truth_values' of 'editDistance' op with data type '"
          << truth_values_attr_T
          << "' must match data type '"
          << hypothesis_values_attr_T
          << "' of argument 'hypothesis_values'";
      throw_exception(env, jvm_illegal_argument_exception, error_msg.str().c_str());
  }

  TFE_OpSetAttrBool(op.get(), "normalize", static_cast<unsigned char>(normalize));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_oneHot(
    JNIEnv* env, jobject object, jlong context_handle, jlong indices, jlong depth, jlong on_value, jlong off_value, jlong axis) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "OneHot", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(indices_tensor_handle, TFE_TensorHandle, indices, 0);
  TFE_OpAddInput(op.get(), indices_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(depth_tensor_handle, TFE_TensorHandle, depth, 0);
  TFE_OpAddInput(op.get(), depth_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(on_value_tensor_handle, TFE_TensorHandle, on_value, 0);
  TFE_OpAddInput(op.get(), on_value_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(off_value_tensor_handle, TFE_TensorHandle, off_value, 0);
  TFE_OpAddInput(op.get(), off_value_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(on_value_attr_T_on_value_tensor_h, TFE_TensorHandle, on_value, 0);
  const TF_DataType on_value_attr_T = TFE_TensorHandleDataType(on_value_attr_T_on_value_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", on_value_attr_T);

  REQUIRE_HANDLE(on_value_attr_T_off_value_tensor_h, TFE_TensorHandle, off_value, 0);
  const TF_DataType off_value_attr_T = TFE_TensorHandleDataType(on_value_attr_T_off_value_tensor_h);
  if (on_value_attr_T != off_value_attr_T) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'off_value' of 'oneHot' op with data type '"
          << off_value_attr_T
          << "' must match data type '"
          << on_value_attr_T
          << "' of argument 'on_value'";
      throw_exception(env, jvm_illegal_argument_exception, error_msg.str().c_str());
  }

  REQUIRE_HANDLE(indices_attr_TI_indices_tensor_h, TFE_TensorHandle, indices, 0);
  const TF_DataType indices_attr_TI = TFE_TensorHandleDataType(indices_attr_TI_indices_tensor_h);
  TFE_OpSetAttrType(op.get(), "TI", indices_attr_TI);

  TFE_OpSetAttrInt(op.get(), "axis", static_cast<int64_t>(axis));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_broadcastArgs(
    JNIEnv* env, jobject object, jlong context_handle, jlong s0, jlong s1) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "BroadcastArgs", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(s0_tensor_handle, TFE_TensorHandle, s0, 0);
  TFE_OpAddInput(op.get(), s0_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(s1_tensor_handle, TFE_TensorHandle, s1, 0);
  TFE_OpAddInput(op.get(), s1_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(s0_attr_T_s0_tensor_h, TFE_TensorHandle, s0, 0);
  const TF_DataType s0_attr_T = TFE_TensorHandleDataType(s0_attr_T_s0_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", s0_attr_T);

  REQUIRE_HANDLE(s0_attr_T_s1_tensor_h, TFE_TensorHandle, s1, 0);
  const TF_DataType s1_attr_T = TFE_TensorHandleDataType(s0_attr_T_s1_tensor_h);
  if (s0_attr_T != s1_attr_T) {
      std::stringstream error_msg;
      error_msg
          << "Argument 's1' of 'broadcastArgs' op with data type '"
          << s1_attr_T
          << "' must match data type '"
          << s0_attr_T
          << "' of argument 's0'";
      throw_exception(env, jvm_illegal_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_stopGradient(
    JNIEnv* env, jobject object, jlong context_handle, jlong input) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "StopGradient", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_tensor_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_attr_T_input_tensor_h, TFE_TensorHandle, input, 0);
  const TF_DataType input_attr_T = TFE_TensorHandleDataType(input_attr_T_input_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", input_attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_preventGradient(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jbyteArray message) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "PreventGradient", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_tensor_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_attr_T_input_tensor_h, TFE_TensorHandle, input, 0);
  const TF_DataType input_attr_T = TFE_TensorHandleDataType(input_attr_T_input_tensor_h);
  TFE_OpSetAttrType(op.get(), "T", input_attr_T);

  jbyte *message_c_value = env->GetByteArrayElements(message, nullptr);
  TFE_OpSetAttrString(op.get(), "message", reinterpret_cast<const char *>(message_c_value));
  env->ReleaseByteArrayElements(message, message_c_value, JNI_ABORT);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}
