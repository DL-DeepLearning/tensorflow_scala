package org.platanios.tensorflow.api

import org.platanios.tensorflow.api.ops.Op
import org.platanios.tensorflow.jni.{Graph => NativeGraph}

/**
  * @author Emmanouil Antonios Platanios
  */
final case class Graph(private var nativeHandle: Long) extends Closeable {
  private object NativeHandleLock
  private var referenceCount: Int = 0

  /** Release resources associated with the Graph.
    *
    * <p>Blocks until there are no active {@link Session} instances referring to this Graph. A Graph
    * is not usable after close returns.
    */
  override def close(): Unit = {
    NativeHandleLock.synchronized {
      if (nativeHandle != 0) {
        while (referenceCount > 0) {
          try {
            NativeHandleLock.wait()
          } catch {
            case _: InterruptedException =>
              Thread.currentThread().interrupt()
              // Possible leak of the graph in this case?
              return
          }
        }
        NativeGraph.delete(nativeHandle)
        nativeHandle = 0
      }
    }
  }

  /** Returns the operation (node in the Graph) with the provided name.
    *
    * <p>Or {@code null} if no such operation exists in the Graph.
    */
  def operation(name: String): Option[Op] = {
    NativeHandleLock.synchronized {
      val operationHandle: Long = NativeGraph.operation(nativeHandle, name)
      if (operationHandle == 0)
        None
      else
        Some(Op(this, operationHandle))
    }
  }

//  /** Returns a builder to add {@link Operation}s to the Graph.
//    *
//    * @param opType of the Operation (i.e., identifies the computation to be performed)
//    * @param name   to refer to the created Operation in the graph.
//    * @return an { @link OperationBuilder}, which will add the Operation to the graph when { @link
//    *                    OperationBuilder#build()} is invoked. If { @link OperationBuilder#build()} is not invoked,
//    *                    then some resources may leak.
//    */
//  def operationBuilder(opType: String, name: String): Operation.Builder = Operation.Builder(this, opType, name)

  /** Import a serialized representation of a TensorFlow graph.
    *
    * @param graphDef the serialized representation of a TensorFlow graph.
    * @param prefix   a prefix that will be prepended to names in graphDef
    * @throws IllegalArgumentException if graphDef is not a recognized serialization of a graph.
    * @see #importGraphDef(byte[])
    */
  @throws[IllegalArgumentException]
  def importGraphDef(graphDef: Array[Byte], prefix: String): Unit = {
    if (graphDef == null || prefix == null)
      throw new IllegalArgumentException("graphDef and prefix cannot be null.")
    NativeHandleLock.synchronized { NativeGraph.importGraphDef(nativeHandle, graphDef, prefix) }
  }

  /** Import a serialized representation of a TensorFlow graph.
    *
    * <p>The serialized representation of the graph, often referred to as a <i>GraphDef</i>, can be
    * generated by {@link #toGraphDef()} and equivalents in other language APIs.
    *
    * @throws IllegalArgumentException if graphDef is not a recognized serialization of a graph.
    * @see #importGraphDef(byte[], String)
    */
  @throws[IllegalArgumentException]
  def importGraphDef(graphDef: Array[Byte]): Unit = importGraphDef(graphDef, "")

  /** Generate a serialized representation of the Graph.
    *
    * @see #importGraphDef(byte[])
    * @see #importGraphDef(byte[], String)
    */
  def toGraphDef: Array[Byte] = {
    NativeHandleLock.synchronized {
      NativeGraph.toGraphDef(nativeHandle)
    }
  }

  def reference: Reference = Reference()

  // Related native objects (such as the TF_Operation object backing an Operation instance)
  // have a validity tied to that of the Graph. The handles to those native objects are not
  // valid after Graph.close() has been invoked.
  //
  // Instances of the Reference class should be used to ensure the Graph has not been closed
  // while dependent handles are in use.
  final case class Reference() extends Closeable {
    NativeHandleLock.synchronized {
      if (Graph.this.nativeHandle == 0)
        throw new IllegalStateException("close() has been called on the Graph")
      referenceCount += 1
    }

    override def close(): Unit = {
      NativeHandleLock.synchronized {
        if (Graph.this.nativeHandle != 0) {
          referenceCount -= 1
          if (referenceCount == 0)
            NativeHandleLock.notifyAll()
        }
      }
    }

    def nativeHandle: Long = {
      NativeHandleLock.synchronized {
        if (Graph.this.nativeHandle != 0)
          Graph.this.nativeHandle
        else
          0
      }
    }
  }
}

object Graph {
  def apply(): Graph = Graph(nativeHandle = NativeGraph.allocate())
}
